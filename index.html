<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PestiVid - Agricultural Blockchain Platform (Web3 Demo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <!-- Font Awesome -->
  <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" rel="stylesheet">
  <!-- Google Fonts (Inter) -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Vue.js -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
  <!-- Axios, Buffer -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <script>
    // window.Buffer = window.buffer.Buffer; // Needed for some web3 libs, including older Solana-web3.js versions
  </script>
  <!-- Note: @solana/web3.js 1.73.0 is included in the original code but commented out in the script section.
       The current simulation doesn't use it, but you'd include it here for a real Solana integration. -->
   <!-- <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.73.0/lib/index.iife.min.js"></script> -->

  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

  <!-- Orange ID (Bedrock Passport) Dependencies -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://public-cdn-files.pages.dev/bedrock-passport.umd.js"></script>
  <!-- Optional: Include Tailwind CSS for styling - Already included for the main app -->
  <!-- <script src="https://cdn.tailwindcss.com"></script> -->


  <style>
    body { font-family: 'Inter', system-ui, sans-serif; background: #f9fafb; }
    html { scroll-behavior: smooth; overflow-x: hidden; }
    ::-webkit-scrollbar { width: 8px; height: 8px; } /* Increased for better visibility */
    ::-webkit-scrollbar-track { background: #f1f1f1; }
    ::-webkit-scrollbar-thumb { background: #b0b0b0; border-radius: 4px; } /* Slightly darker */
    ::-webkit-scrollbar-thumb:hover { background: #9a9a9a; } /* Hover state */
    * { scrollbar-width: thin; scrollbar-color: #b0b0b0 #f1f1f1; -ms-overflow-style: -ms-autohiding-scrollbar; } /* Firefox support */
    .progress-bar { height: 8px; border-radius: 4px; background: #e5e7eb; overflow: hidden; }
    .progress-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
    .modal-scrollable { max-height: 85vh; overflow-y: auto; }
    .project-updates-list { max-height: 150px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 0.375rem; padding: 0.75rem; background-color: #f9fafb; }
    .project-update-item { padding-bottom: 0.5rem; margin-bottom: 0.5rem; border-bottom: 1px solid #f3f4f6; }
    .project-update-item:last-child { border-bottom: none; margin-bottom: 0; }
    .weather-card { background-color: #fff; border-radius: 0.5rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); }
    .forecast-day { text-align: center; padding: 0.75rem; background-color: #f9fafb; border-radius: 0.375rem; border: 1px solid #e5e7eb; }
    .message-view-container { scroll-behavior: smooth; }
    .notification-badge { position: absolute; top: -5px; right: -8px; min-width: 18px; height: 18px; background-color: #ef4444; border-radius: 9px; color: white; font-size: 10px; font-weight: 600; line-height: 18px; text-align: center; padding: 0 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    .mobile-notification-badge { display: inline-block; background-color: #ef4444; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 9px; line-height: 16px; text-align: center; vertical-align: top; margin-left: 4px; }
    .notification-toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column-reverse; gap: 10px; align-items: flex-end; }
    .notification-toast { min-width: 250px; max-width: 350px; background-color: #fff; color: #333; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); display: flex; align-items: center; opacity: 0; transform: translateX(100%); transition: all 0.4s cubic-bezier(0.68, -055, 027, 155); }
    .notification-toast.show { opacity: 1; transform: translateX(0); }
    .notification-toast .icon { margin-right: 0.75rem; font-size: 1.25rem; }
    .notification-toast .icon-info { color: #3b82f6; } .notification-toast .icon-success { color: #10b981; } .notification-toast .icon-warning { color: #f59e0b; } .notification-toast .icon-error { color: #ef4444; }
    .notification-toast .message { font-size: 0.875rem; line-height: 1.3; }
    .notification-toast .close-btn { margin-left: auto; padding-left: 0.75rem; color: #9ca3af; cursor: pointer; background: none; border: none; font-size: 1rem; }
    .notification-toast .close-btn:hover { color: #6b7280; }
    .new-badge { position: absolute; top: -8px; right: -8px; background-color: #3b82f6; color: white; font-size: 10px; font-weight: bold; padding: 2px 6px; border-radius: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
    .loading-modal { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; }
    .loading-content { background-color: white; padding: 2rem; border-radius: 0.5rem; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
    .loading-content .fa-spinner { font-size: 2rem; color: #10b981; margin-bottom: 1rem; }
    .login-page-container { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: calc(100vh - 160px); padding: 2rem 1rem; box-sizing: border-box; }
    .login-branding { display: flex; align-items: center; margin-bottom: 1.5rem; }
    .login-branding .logo-icon { font-size: 2.5rem; color: #15803d; margin-right: 0.75rem; }
    .login-branding .app-name { font-size: 2rem; font-weight: 600; color: #15803d; }
    .login-panel-wrapper { background-color: white; padding: 2rem; border-radius: 1rem; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); width: 100%; max-width: 450px; text-align: center; }
    .login-panel-wrapper h2 { font-size: 1.5rem; font-weight: 700; color: #166534; /* green-800 */ margin-bottom: 0.5rem; }
    .login-panel-wrapper .tagline { color: #4b5563; /* gray-600 */ margin-bottom: 1.5rem; font-size: 0.9rem; }

    /* Fix for horizontal overflow on tables */
    .overflow-x-auto table {
        width: 100%;
        min-width: 600px; /* Adjust as needed */
    }
    /* Adjust mobile padding/spacing for login panel */
    @media (max-width: 640px) {
         .login-panel-wrapper {
             padding: 1.5rem;
         }
         .login-panel-wrapper h2 {
             font-size: 1.25rem;
         }
         .login-panel-wrapper .tagline {
             font-size: 0.8rem;
             margin-bottom: 1rem;
         }
         .login-branding .logo-icon { font-size: 2rem; }
         .login-branding .app-name { font-size: 1.75rem; }
    }

    /* Style Bedrock widget container */
    #bedrock-react-container {
        /* Ensure the container has some padding/margins */
        padding: 1rem;
        margin: 0 auto; /* Center the container if needed */
         min-height: 350px; /* Give it some minimum height */
         display: flex; /* Use flex to center contents */
         flex-direction: column;
         justify-content: center;
         align-items: center;
         /* Remove conflicting styles that might interfere with Bedrock Panel CSS */
         background-color: transparent; /* Let the parent panel wrapper handle background */
         box-shadow: none; /* Let the parent panel wrapper handle shadow */
    }
     /* Hidden container for the Bedrock State Bridge */
    #bedrock-bridge-container {
         display: none;
    }
  </style>
</head>
<body class="text-gray-900">
<div id="app" class="flex flex-col min-h-screen">
  <!-- Header/Navbar -->
  <header class="bg-white shadow sticky top-0 z-30">
    <div class="max-w-7xl mx-auto px-5 py-4 flex justify-between items-center">
      <div class="flex items-center space-x-2">
        <span class="text-2xl text-green-700 font-semibold"><i class="fas fa-seedling mr-1"></i>PestiVid</span>
      </div>
      <nav class="hidden md:flex space-x-5 items-center">
        <a href="#" @click.prevent="switchPage('landing')" :class="{'font-bold text-green-700': current==='landing'}" class="hover:text-green-600">Home</a>

        <!-- Show Login/Signup only if NOT authenticated via Bedrock -->
        <a v-if="!bedrockIsAuthenticated && !isAuthProcessing" href="#" @click.prevent="switchPage('loginChoice')" class="hover:text-green-600">Login / Sign Up</a>
        <!-- Show loading state if authentication is in progress -->
        <span v-if="isAuthProcessing" class="text-gray-500 text-sm">Authenticating...</span>


        <!-- Show Nav items ONLY if authenticated via Bedrock (and PestiVid profile loaded) -->
        <template v-if="bedrockIsAuthenticated && role">
          <a href="#" @click.prevent="switchPage('messaging')" :class="{'font-bold text-green-700': current==='messaging'}" class="hover:text-green-600 relative">
            <i class="fas fa-comments mr-1"></i>Messages
            <span v-if="unreadMessageCount > 0" class="notification-badge">{{ unreadMessageCount }}</span>
          </a>
          <!-- Farmer Menu -->
          <template v-if="role==='farmer'">
            <a href="#" @click.prevent="switchPage('farmerPestiVid')" :class="{'font-bold text-green-700': current==='farmerPestiVid'}" class="hover:text-green-600">PestiVid</a>
            <a href="#" @click.prevent="switchPage('farmerAgriStream')" :class="{'font-bold text-green-700': current==='farmerAgriStream'}" class="hover:text-green-600">AgriStream</a>
            <a href="#" @click.prevent="switchPage('farmerSell')" :class="{'font-bold text-green-700': current==='farmerSell'}" class="hover:text-green-600">Sell</a>
            <a href="#" @click.prevent="switchPage('farmerFunding')" :class="{'font-bold text-green-700': current==='farmerFunding'}" class="hover:text-green-600">Get Funding</a>
             <a href="#" @click.prevent="switchPage('plantRecomendation')" :class="{'font-bold text-green-700': current==='plantRecomendation'}" class="hover:text-green-600">PlantRecommend</a>
          </template>
          <!-- Buyer Menu -->
          <template v-if="role==='buyer'">
            <a href="#" @click.prevent="switchPage('buyerAgriSell')" :class="{'font-bold text-green-700': current==='buyerAgriSell'}" class="hover:text-green-600">AgriSell</a>
          </template>
          <!-- Investor Menu -->
          <template v-if="role==='investor'">
            <a href="#" @click.prevent="switchPage('investorProjects')" :class="{'font-bold text-green-700': current==='investorProjects'}" class="hover:text-green-600">Projects</a>
            <a href="#" @click.prevent="switchPage('investorPortfolio')" :class="{'font-bold text-green-700': current==='investorPortfolio'}" class="hover:text-green-600">Portfolio</a>
          </template>
          <a href="#" @click.prevent="switchPage('userProfile')" :class="{'font-bold text-green-700': current==='userProfile'}" class="bg-green-600 text-white text-xs rounded-full px-3 py-1 select-none ml-2 hover:bg-green-700 flex items-center">
             <i class="fas fa-user-circle mr-1"></i> {{ userName ? userName.split(' ')[0] : displayedUserIdentifier }}
          </a>
           <!-- Unified Logout Button -->
           <a href="#" title="Sign Out" @click.prevent="handleLogoutClick" class="text-gray-400 hover:text-red-500 ml-2"><i class="fas fa-sign-out-alt text-lg"></i></a>
        </template>
      </nav>
      <button class="md:hidden text-gray-500 focus:outline-none" @click="showMobileMenu = !showMobileMenu">
        <i class="fas fa-bars text-2xl"></i>
      </button>
    </div>
    <!-- Mobile Dropdown -->
    <div v-show="showMobileMenu" class="md:hidden bg-white border-t z-40">
      <div class="py-2 flex flex-col space-y-1 px-4">
        <a href="#" @click.prevent="switchPage('landing');showMobileMenu=false" :class="{'font-bold text-green-700': current==='landing'}">Home</a>
         <!-- Show Login/Signup only if NOT authenticated via Bedrock -->
        <a v-if="!bedrockIsAuthenticated && !isAuthProcessing" href="#" @click.prevent="switchPage('loginChoice');showMobileMenu=false" >Login / Sign Up</a>
         <span v-if="isAuthProcessing" class="text-gray-500 text-sm px-1 py-1">Authenticating...</span>

         <!-- Show Nav items ONLY if authenticated via Bedrock (and PestiVid profile loaded) -->
        <template v-if="bedrockIsAuthenticated && role">
          <a href="#" @click.prevent="switchPage('messaging');showMobileMenu=false" :class="{'font-bold text-green-700': current==='messaging'}" class="flex items-center">
            <i class="fas fa-comments mr-1"></i>Messages
            <span v-if="unreadMessageCount > 0" class="mobile-notification-badge">{{ unreadMessageCount }}</span>
          </a>
          <template v-if="role==='farmer'">
            <a href="#" @click.prevent="switchPage('farmerPestiVid');showMobileMenu=false" :class="{'font-bold text-green-700': current==='farmerPestiVid'}">PestiVid</a>
            <a href="#" @click.prevent="switchPage('farmerAgriStream');showMobileMenu=false" :class="{'font-bold text-green-700': current==='farmerAgriStream'}">AgriStream</a>
            <a href="#" @click.prevent="switchPage('farmerSell');showMobileMenu=false" :class="{'font-bold text-green-700': current==='farmerSell'}">Sell</a>
            <a href="#" @click.prevent="switchPage('farmerFunding');showMobileMenu=false" :class="{'font-bold text-green-700': current==='farmerFunding'}">Get Funding</a>
             <a href="#" @click.prevent="switchPage('plantRecomendation');showMobileMenu=false" :class="{'font-bold text-green-700': current==='plantRecomendation'}">PlantRecommend</a>
          </template>
          <template v-if="role==='buyer'">
            <a href="#" @click.prevent="switchPage('buyerAgriSell');showMobileMenu=false" :class="{'font-bold text-green-700': current==='buyerAgriSell'}">AgriSell</a>
          </template>
          <template v-if="role==='investor'">
            <a href="#" @click.prevent="switchPage('investorProjects');showMobileMenu=false" :class="{'font-bold text-green-700': current==='investorProjects'}">Projects</a>
            <a href="#" @click.prevent="switchPage('investorPortfolio');showMobileMenu=false" :class="{'font-bold text-green-700': current==='investorPortfolio'}">Portfolio</a>
          </template>
          <div class="border-t mt-2 pt-2 flex justify-between items-center">
            <a href="#" @click.prevent="switchPage('userProfile');showMobileMenu=false" :class="{'font-bold text-green-700': current==='userProfile'}" class="inline-block bg-green-600 text-white text-xs rounded px-2 py-1 ml-1 flex items-center">
               <i class="fas fa-user-circle mr-1"></i> {{ userName ? userName.split(' ')[0] : displayedUserIdentifier }}
            </a>
            <!-- Unified Mobile Logout Button -->
            <a href="#" class="text-gray-400 hover:text-red-500" title="Sign Out" @click.prevent="handleLogoutClick();showMobileMenu=false"><i class="fas fa-sign-out-alt"></i></a>
          </div>
        </template>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="flex-1 max-w-7xl mx-auto w-full px-4 pt-8 pb-8">
    <!-- Landing Section -->
    <section v-if="current==='landing'">
        <div class="flex flex-col md:flex-row items-center mb-12 pt-2">
            <div class="md:w-1/2 md:pr-8">
            <h1 class="text-4xl font-bold text-green-800 mb-4">PestiVid: Blockchain Transparency in Agriculture</h1>
            <p class="mb-5 text-gray-800 text-lg leading-relaxed">A secure, video-verified agricultural marketplace with investment opportunities. Farmers prove quality and safety via field recordings stored on blockchain (Solana Simulated) and IPFS. Buyers purchase crops with complete confidence and traceability. Investors fund projects with transparent returns.</p>
            <ul class="text-gray-700 mb-7 space-y-1 text-base">
                <li><i class="fas fa-link text-green-500 mr-2"></i>Solana blockchain-simulated transactions</li>
                <li><i class="fas fa-cloud-upload-alt text-green-400 mr-2"></i>Decentralized video storage (IPFS/Pinata)</li>
                <li><i class="fas fa-search-dollar text-green-400 mr-2"></i>Full traceability for buyers</li>
                <li><i class="fas fa-handshake text-green-500 mr-2"></i>Direct, transparent marketplace transactions</li>
                <li><i class="fas fa-chart-line text-green-500 mr-2"></i>Investment opportunities for funders</li>
                <li><i class="fas fa-comments text-green-500 mr-2"></i>Secure messaging between users</li>
                <li><i class="fas fa-bell text-green-500 mr-2"></i>Real-time notifications</li>
            </ul>
            <div class="mt-4 space-x-2">
                <!-- Adjusted Get Started logic -->
                <button class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded transition" @click="getStarted">Get Started</button>
                 <!-- Adjusted Browse Marketplace logic - redirects based on auth state -->
                <button class="bg-white border border-green-600 text-green-600 px-6 py-2 rounded transition" @click="bedrockIsAuthenticated && role === 'buyer' ? switchPage('buyerAgriSell') : getStarted()">Browse Marketplace</button>
            </div>
            </div>
            <div class="md:w-1/2 mt-10 md:mt-0 flex flex-col items-center">
            <video controls playsinline webkit-playsinline class="rounded-lg shadow-md border w-full max-w-md mx-auto">
                <source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4">
                Demo video: your browser does not support video.
            </video>
            </div>
        </div>
        <div class="mt-10">
            <h2 class="text-2xl text-green-700 font-semibold mb-3">How It Works</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-5">
            <div class="bg-white rounded-lg shadow p-5 flex flex-col items-center">
                <i class="fas fa-video text-2xl text-green-500 mb-3"></i>
                <span class="font-bold mb-1">1. Video Recording</span>
                <p class="text-sm text-gray-600 text-center">Farmers film direct evidence of their crop and practices.</p>
            </div>
            <div class="bg-white rounded-lg shadow p-5 flex flex-col items-center">
                <i class="fas fa-cloud-upload-alt text-2xl text-green-500 mb-3"></i>
                <span class="font-bold mb-1">2. Upload to IPFS</span>
                <p class="text-sm text-gray-600 text-center">Videos & info are securely uploaded and stored decentrally.</p>
            </div>
            <div class="bg-white rounded-lg shadow p-5 flex flex-col items-center">
                <i class="fas fa-search-dollar text-2xl text-green-500 mb-3"></i>
                <span class="font-bold mb-1">3. Verification</span>
                <p class="text-sm text-gray-600 text-center">Buyers view blockchain-verified video before any purchase.</p>
            </div>
            <div class="bg-white rounded-lg shadow p-5 flex flex-col items-center">
                <i class="fas fa-handshake text-2xl text-green-500 mb-3"></i>
                <span class="font-bold mb-1">4. Marketplace</span>
                <p class="text-sm text-gray-600 text-center">Login to buy, sell, or invest, all backed by video trust.</p>
            </div>
            </div>
        </div>

        <div class="mt-16 bg-green-50 rounded-lg p-8">
            <h2 class="text-2xl text-green-700 font-semibold mb-3">Agricultural Investment Platform</h2>
            <div class="flex flex-col md:flex-row items-center">
            <div class="w-full">
                <p class="mb-4 text-gray-700">Invest in verified agricultural projects with full transparency. Track your investments through simulated Solana blockchain technology and share in the harvest profits.</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 my-6">
                <div class="bg-white rounded p-4 shadow-sm">
                    <i class="fas fa-seedling text-green-600 text-2xl mb-2"></i>
                    <h3 class="font-bold mb-1">Fund Crops</h3>
                    <p class="text-sm">Invest in specific crops with transparent land use and practices.</p>
                </div>
                <div class="bg-white rounded p-4 shadow-sm">
                    <i class="fas fa-coins text-green-600 text-2xl mb-2"></i>
                    <h3 class="font-bold mb-1">Share Returns</h3>
                    <p class="text-sm">Receive dividends based on harvest yields and market prices.</p>
                </div>
                <div class="bg-white rounded p-4 shadow-sm">
                    <i class="fas fa-shield-alt text-green-600 text-2xl mb-2"></i>
                    <h3 class="font-bold mb-1">Secure Blockchain</h3>
                    <p class="text-sm">All investments and harvests recorded on immutable ledger (Simulated).</p>
                </div>
                </div>
                 <!-- Adjusted Become an Investor logic - redirects based on auth state -->
                <button class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded transition mt-2" @click="bedrockIsAuthenticated && role === 'investor' ? switchPage('investorProjects') : getStarted()">Become an Investor</button>
            </div>
            </div>
        </div>
    </section>

    <!-- Login Choice Page (Now uses Orange ID widget) -->
    <section v-if="current==='loginChoice'" class="login-page-container">
        <div class="login-panel-wrapper">
            <div class="login-branding justify-center ">
                <i class="fas fa-seedling logo-icon"></i>
                <span class="app-name">PestiVid</span>
            </div>
            <!-- Content injected by renderBedrockLoginWidget Vue method -->
             <div id="bedrock-react-container" class="w-full">
                <!-- React Bedrock Passport Widget renders here -->
             </div>
        </div>
    </section>

    <!-- Role Selection (after any login if new PestiVid user) -->
    <!-- Ensure this section only shows if Bedrock authenticated BUT PestiVid profile is NOT complete (role missing) -->
    <section v-if="current==='roleSelection' && bedrockIsAuthenticated && !role" class="max-w-lg mx-auto bg-white shadow rounded-lg p-8 mt-8">
        <h2 class="text-2xl font-bold text-green-700 mb-4">Welcome to PestiVid!</h2>
        <p class="text-gray-600 mb-1">
            Your Orange ID <strong class="font-mono text-sm break-all">{{ currentUserIdentifier }}</strong> is connected.
        </p>
        <p class="text-gray-600 mb-5">Please complete your PestiVid profile and select your primary role:</p>
        <div class="mb-4">
            <label class="block text-gray-600 mb-1">Full Name (for PestiVid) <span class="text-red-500">*</span></label>
            <input v-model.trim="userNameOnboarding" type="text" class="w-full px-3 py-2 border rounded" placeholder="e.g., John Doe" required>
        </div>
        <div class="mb-4">
            <label class="block text-gray-600 mb-1">Email Address (for PestiVid) <span class="text-red-500">*</span></label>
            <input v-model.trim="userEmailOnboarding" type="email" class="w-full px-3 py-2 border rounded" placeholder="e.g., john.doe@example.com" required>
        </div>
        <div class="mb-4">
            <label class="block text-gray-600 mb-1">Phone Number (Optional)</label>
            <input v-model.trim="userPhoneOnboarding" type="tel" class="w-full px-3 py-2 border rounded" placeholder="e.g., +1-555-123-4567">
        </div>
        <div class="mb-6">
          <label class="block text-gray-600 mb-1">Primary Role in PestiVid <span class="text-red-500">*</span></label>
          <select v-model="selectedRoleOnboarding" class="w-full px-3 py-2 border rounded bg-white" required>
            <option value="" disabled>Select Role</option>
            <option value="farmer">Farmer</option>
            <option value="buyer">Buyer</option>
            <option value="investor">Investor</option>
          </select>
        </div>
         <div class="mb-4" v-if="selectedRoleOnboarding === 'farmer'">
            <label class="block text-gray-600 mb-1">Farm/City Name for Weather (Optional)</label>
            <input v-model.trim="farmerLocationCityOnboarding" type="text" class="w-full px-3 py-2 border rounded" placeholder="e.g., Davis, California">
         </div>
        <button @click="completeOnboarding" class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded" :disabled="!selectedRoleOnboarding || !userNameOnboarding.trim() || !userEmailOnboarding.trim()">Confirm Profile & Role</button>
    </section>

    <section v-if="current==='farmerPestiVid'" class="max-w-3xl mx-auto mt-6">
      <!-- Gate access based on bedrockIsAuthenticated and role -->
      <div v-if="!bedrockIsAuthenticated || role !== 'farmer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Farmer to access PestiVid video recording.</p> </div>
      <div v-else>
           <h2 class="text-2xl font-bold text-green-700 mb-4"><i class="fas fa-video mr-2"></i>PestiVid: Record Crop Video</h2>
           <div class="bg-white rounded shadow-md p-6 space-y-6">
             <form @submit.prevent>
               <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                 <div> <label class="block text-gray-600 mb-1 text-sm">Crop Type</label> <input v-model="recordForm.crop" class="w-full px-2 py-2 border rounded text-sm" required placeholder="e.g., Tomatoes"> </div>
                 <div> <label class="block text-gray-600 mb-1 text-sm">Field Location</label> <input v-model="recordForm.location" class="w-full px-2 py-2 border rounded text-sm" required placeholder="e.g., South Field"> </div>
                 <div> <label class="block text-gray-600 mb-1 text-sm">Pesticide Used</label> <input v-model="recordForm.pesticide" class="w-full px-2 py-2 border rounded text-sm" required placeholder="e.g., Neem Oil"> </div>
                 <div> <label class="block text-gray-600 mb-1 text-sm">Pesticide Company</label> <input v-model="recordForm.pesticideCompany" class="w-full px-2 py-2 border rounded text-sm" required placeholder="e.g., AgriChem"> </div>
               </div>
               <div class="mb-4">
                 <label class="block text-gray-600 mb-1 text-sm">Purpose of this Video:</label>
                 <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-2 sm:space-y-0">
                     <label class="flex items-center"> <input type="radio" v-model="recordForm.purpose" value="agristream" class="form-radio text-green-600"> <span class="ml-2 text-sm text-gray-700">For AgriStream (General)</span> </label>
                     <label class="flex items-center"> <input type="radio" v-model="recordForm.purpose" value="sell" class="form-radio text-green-600"> <span class="ml-2 text-sm text-gray-700">To List for Sale</span> </label>
                     <label class="flex items-center"> <input type="radio" v-model="recordForm.purpose" value="funding" class="form-radio text-green-600"> <span class="ml-2 text-sm text-gray-700">For Funding Request</span> </label>
                 </div>
               </div>
             </form>
             <div>
               <div class="aspect-w-16 aspect-h-9 bg-black rounded mb-3 relative" style="min-height:200px">
                 <video ref="liveVideo" v-show="showLive" class="w-full h-full rounded absolute inset-0 object-cover" autoplay muted playsinline webkit-playsinline style="background:#111"></video>
                 <video v-if="recordBlobUrl" :src="recordBlobUrl" controls playsinline webkit-playsinline class="w-full h-full rounded absolute inset-0 object-cover" style="background:#181818"></video>
                 <div v-if="!showLive && !recordBlobUrl" class="absolute inset-0 flex justify-center items-center h-full text-gray-400"><i class="fas fa-video-slash fa-2x"></i><p class="ml-3">Video preview area</p></div>
               </div>
               <div class="flex flex-wrap gap-3 mb-2 items-center">
                 <button type="button" :disabled="recording || uploading || !bedrockIsAuthenticated || role !== 'farmer' || !recordForm.crop || !recordForm.location || !recordForm.pesticide || !recordForm.pesticideCompany || !recordForm.purpose" @click="startVideo" :class="{'opacity-50 cursor-not-allowed': recording || uploading || !bedrockIsAuthenticated || role !== 'farmer' || !recordForm.crop || !recordForm.location || !recordForm.pesticide || !recordForm.pesticideCompany || !recordForm.purpose}" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm">
                   <i :class="recording ? 'fas fa-spinner fa-spin' : (recordBlobUrl ? 'fas fa-redo' : 'fas fa-record-vinyl')" class="mr-1"></i>
                   {{ recordBlobUrl ? 'Re-Record' : (recording ? 'Starting...' : 'Start Recording') }}
                 </button>
                 <button v-if="recording" type="button" @click="stopVideo" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded text-sm"> <i class="fas fa-stop mr-1"></i>Stop </button>
                 <button v-if="recordBlobUrl && !uploading" type="button" @click="uploadVideo" :disabled="uploading || !bedrockIsAuthenticated || role !== 'farmer' || pinataJwt === 'YOUR_PINATA_JWT' || pinataJwt.includes('YOUR_') || pinataGateway === 'YOUR_PINATA_GATEWAY_HOSTNAME' || pinataGateway.includes('YOUR_')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm"
                 :class="{'opacity-50 cursor-not-allowed': uploading || !bedrockIsAuthenticated || role !== 'farmer' || pinataJwt === 'YOUR_PINATA_JWT' || pinataJwt.includes('YOUR_') || pinataGateway === 'YOUR_PINATA_GATEWAY_HOSTNAME' || pinataGateway.includes('YOUR_')}">
                  <i :class="uploading ? 'fas fa-spinner fa-spin' : 'fas fa-upload'" class="mr-1"></i> {{ uploading ? 'Uploading...' : (pinataJwt === 'YOUR_PINATA_JWT' || pinataJwt.includes('YOUR_') || pinataGateway === 'YOUR_PINATA_GATEWAY_HOSTNAME' || pinataGateway.includes('YOUR_') ? 'Add Pinata Keys' : 'Upload to IPFS') }} </button>
                  <div v-if="uploading" class="flex items-center text-blue-600 text-sm ml-3"> <i class="fas fa-spinner fa-spin mr-2"></i> Uploading... Please wait. </div>
               </div>
               <p class="text-xs mt-2 text-gray-500">Allow camera access. Video file is stored locally until upload.</p>
               <div v-if="pinataJwt === 'YOUR_PINATA_JWT' || pinataJwt.includes('YOUR_') || pinataGateway === 'YOUR_PINATA_GATEWAY_HOSTNAME' || pinataGateway.includes('YOUR_')" class="mt-4 bg-yellow-100 border border-yellow-300 text-yellow-700 p-3 rounded text-sm">
                  <p class="font-bold">Pinata API Key Warning:</p>
                  <p>Please replace <code>YOUR_PINATA_JWT</code> and <code>YOUR_PINATA_GATEWAY_HOSTNAME</code> in the code with your actual keys/hostname for IPFS uploads to work.</p>
              </div>
               <div v-if="uploadCid" class="text-green-600 mt-3 bg-green-50 p-3 rounded border border-green-200 text-sm">
                   <div class="flex items-center mb-2"> <i class="fas fa-check-circle mr-2"></i> Uploaded to IPFS! CID: <span class="font-mono bg-green-100 px-1 py-0.5 rounded break-all ml-1">{{ uploadCid }}</span> </div>
                   <p v-if="lastUploadedVideoPurpose === 'agristream'" class="mt-1 text-gray-700"> This video is now available in your AgriStream. <a href="#" @click.prevent="navigateToPageWithParam('farmerAgriStream', 'highlightCid', uploadCid)" class="text-blue-700 underline font-medium hover:text-blue-800 ml-1">View in AgriStream</a>. <br>You can also use it later to: <a href="#" @click.prevent="goToListing(uploadCid)" class="text-green-700 underline font-medium hover:text-green-800">Create a Listing</a>, or <a href="#" @click.prevent="navigateToPageWithParam('farmerFunding', 'cid', uploadCid)" class="text-purple-700 underline font-medium hover:text-purple-800 ml-1">Use for Funding Request</a>. </p>
                   <p v-if="lastUploadedVideoPurpose === 'sell'" class="mt-1 text-gray-700"> Video uploaded for selling! You should be redirected to create a listing. If not, <a href="#" @click.prevent="navigateToPageWithParam('farmerSell', 'cid', uploadCid)" class="text-green-700 underline font-medium hover:text-green-800">click here to complete the listing</a>. </p>
                   <p v-if="lastUploadedVideoPurpose === 'funding'" class="mt-1 text-gray-700"> Video uploaded for a funding request! You should be redirected to create the request. If not, <a href="#" @click.prevent="navigateToPageWithParam('farmerFunding', 'cid', uploadCid)" class="text-purple-700 underline font-medium hover:text-purple-800">click here to complete the funding request</a>. </p>
               </div>
               <div v-if="uploadError" class="text-red-600 mt-3 bg-red-50 p-2 rounded border border-red-200 text-sm"> <i class="fas fa-exclamation-triangle mr-1"></i> {{ uploadError }} </div>
             </div>
           </div>
      </div>
    </section>
    <section v-if="current==='farmerAgriStream'" class="max-w-4xl mx-auto mt-6">
        <div v-if="!bedrockIsAuthenticated || role !== 'farmer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Farmer to access AgriStream.</p> </div>
        <div v-else>
            <h2 class="text-2xl font-bold text-green-700 mb-5"><i class="fas fa-stream mr-2"></i>AgriStream: My Crop Videos</h2>
            <div class="bg-white rounded shadow-md p-6">
               <div v-if="farmerVideos.length===0" class="text-gray-600 text-center p-6 bg-gray-50 rounded"> <i class="fas fa-film text-4xl text-gray-400 mb-3"></i><br> No uploads yet. Go to <a href="#" class="text-green-700 underline" @click.prevent="switchPage('farmerPestiVid')">PestiVid</a> to upload. </div>
               <div v-else class="space-y-6">
               <div v-for="vid in farmerVideos" :key="vid.id" class="flex flex-col md:flex-row items-start border-b last:border-b-0 pb-6 gap-6 transition-all duration-500" :ref="'videoCard-' + vid.cid" :class="{'bg-yellow-50 border-l-4 border-yellow-400 shadow-lg transform scale-102': vid.cid === highlightedAgriStreamVideoCid}">
                   <div class="w-full md:w-60 flex-shrink-0"> <video :src="ipfsUrl(vid.cid)" controls playsinline webkit-playsinline class="rounded shadow w-full bg-black"></video> </div>
                   <div class="flex-1">
                   <div class="font-bold text-lg">{{ vid.crop }}</div>
                   <div class="text-xs mb-1" :class="{ 'text-blue-700': vid.purpose === 'sell', 'text-purple-700': vid.purpose === 'funding', 'text-gray-600': vid.purpose === 'agristream' || !vid.purpose }"> Intended for: <span class="font-semibold"> {{ vid.purpose === 'sell' ? 'Listing for Sale' : (vid.purpose === 'funding' ? 'Funding Request' : (vid.purpose === 'agristream' ? 'AgriStream (General)' : 'N/A')) }} </span> </div>
                   <div class="text-sm mb-1">Location: <span class="font-mono text-gray-700">{{ vid.location }}</span></div>
                   <div class="text-sm mb-1">Pesticide: <span class="font-mono text-gray-700">{{ vid.pesticide }}</span></div>
                   <div class="text-sm mb-1">Pesticide Co.: <span class="font-mono text-gray-700">{{ vid.pesticideCompany || 'N/A' }}</span></div>
                   <div class="text-xs text-gray-500 mb-2">CID: <span class="font-mono break-all">{{ vid.cid }}</span></div>
                   <a :href="ipfsUrl(vid.cid)" target="_blank" class="text-blue-600 hover:underline text-xs mr-3"><i class="fas fa-external-link-alt mr-1"></i>View on Gateway</a>
                   <button v-if="!isListed(vid.cid) && !isUsedInFunding(vid.cid)" @click="goToListing(vid.cid)" class="text-green-600 hover:underline text-xs" title="Create a marketplace listing for this video"> <i class="fas fa-tags mr-1"></i> Create Listing </button>
                    <span v-else-if="isListed(vid.cid)" class="text-gray-500 text-xs"><i class="fas fa-check mr-1"></i>Already Listed</span>
                    <span v-else-if="isUsedInFunding(vid.cid)" class="text-gray-500 text-xs"><i class="fas fa-check mr-1"></i>Used for Funding</span>

                   <button v-if="!isUsedInFunding(vid.cid) && !isListed(vid.cid)" @click="navigateToPageWithParam('farmerFunding', 'cid', vid.cid)" class="text-purple-600 hover:underline text-xs ml-2" title="Use this video for a funding request"> <i class="fas fa-hand-holding-usd mr-1"></i> Use for Funding </button>
                    <span v-if="isUsedInFunding(vid.cid)" class="text-gray-500 text-xs ml-2"><i class="fas fa-check mr-1"></i>Used for Funding</span>
                    <span v-else-if="isListed(vid.cid)" class="text-gray-500 text-xs ml-2"><i class="fas fa-check mr-1"></i>Already Listed</span>
                   </div>
               </div>
               </div>
           </div>
        </div>
    </section>
    <section v-if="current==='farmerSell'" class="max-w-2xl mx-auto mt-6">
         <div v-if="!bedrockIsAuthenticated || role !== 'farmer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Farmer to sell crops.</p> </div>
         <div v-else>
            <h2 class="text-2xl font-bold text-green-700 mb-4"><i class="fas fa-tags mr-2"></i>Sell Farm Crop on Marketplace</h2>
            <div class="bg-white rounded shadow-md p-6">
               <form @submit.prevent="createListing">
                 <div class="mb-4">
                   <label class="block text-gray-600 mb-1">Select Uploaded Video (Unlisted & Not Used for Funding Only)</label>
                   <select v-model="listingForm.cid" class="w-full px-3 py-2 border rounded bg-white mb-2" required>
                     <option value="" disabled>Select video...</option>
                     <option v-for="vid in availableVideosForListing" :key="vid.id" :value="vid.cid"> {{ vid.crop }} ({{ vid.location }}) - Pest: {{ vid.pesticide }} by {{ vid.pesticideCompany || 'N/A' }} (CID: {{ vid.cid.substring(0,8) }}...) </option>
                     <option v-if="farmerVideos.length > 0 && availableVideosForListing.length === 0" disabled>No unlisted/unused videos available</option>
                      <option v-if="farmerVideos.length === 0" disabled>No videos uploaded yet</option>
                   </select>
                   <p v-if="farmerVideos.length === 0" class="text-xs text-red-500">You need to upload a video first via PestiVid.</p>
                   <p v-if="farmerVideos.length > 0 && availableVideosForListing.length === 0" class="text-xs text-yellow-600">All your 'For Sale' or 'General' videos are already associated with listings or funding requests.</p>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-5">
                   <div> <label class="block text-gray-600 mb-1">Min Price (SOL)</label> <input type="number" v-model.number="listingForm.minPrice" class="w-full px-3 py-2 border rounded" min="0.01" step="0.01" required placeholder="e.g., 0.5"> </div>
                   <div> <label class="block text-gray-600 mb-1">Max Price (SOL)</label> <input type="number" v-model.number="listingForm.maxPrice" class="w-full px-3 py-2 border rounded" :min="listingForm.minPrice || 0.01" step="0.01" required placeholder="e.g., 1.5"> </div>
                 </div>
                 <div class="mb-4"> <label class="flex items-center"> <input type="checkbox" v-model="listingForm.notifyBuyers" class="form-checkbox h-4 w-4 text-green-600"> <span class="ml-2 text-sm text-gray-700">Notify potential buyers about this listing</span> </label> </div>
                 <button type="submit" class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded w-full" :disabled="!listingForm.cid || listingForm.minPrice === null || listingForm.maxPrice === null || !bedrockIsAuthenticated || role !== 'farmer'"> <i class="fas fa-plus-circle mr-1"></i>Create Listing </button>
               </form>
               <div v-if="createdListingId" class="bg-green-100 text-green-700 px-4 py-3 mt-4 rounded font-medium text-sm"> <i class="fas fa-check mr-1"></i> Listing created successfully! Tx: <span class="font-mono text-xs">{{ createdListingId.substring(0,10) }}...</span> <div v-if="listingNotificationSent" class="mt-1 text-sm"> <i class="fas fa-bell mr-1"></i> Buyers have been notified about your new listing. </div> </div>
               <div class="mt-8">
                 <h3 class="font-semibold mb-2 text-gray-700">Your Active Listings</h3>
                 <div v-if="farmerListings.length===0" class="text-gray-600 text-sm bg-gray-50 p-4 rounded text-center">You have no active listings.</div>
                 <div v-else class="overflow-x-auto">
                 <ul v-else class="space-y-3">
                   <li v-for="l in farmerListings" :key="l.id" class="py-3 px-4 border rounded flex flex-col sm:flex-row justify-between sm:items-center text-sm bg-white shadow-sm">
                     <div> <span class="font-medium">{{ l.crop }}</span> <span class="text-xs text-gray-500 ml-1"> ({{l.location}})</span> <br> <span class="text-xs text-gray-500"> CID: {{l.cid.substring(0, 8)}}...</span> | <span class="text-xs text-gray-500"> Pest. Co: {{ l.pesticideCompany || 'N/A' }}</span> <div v-if="l.notificationSent" class="text-xs text-green-600 mt-1"> <i class="fas fa-bell mr-1"></i> Buyers notified </div> </div>
                     <div class="mt-2 sm:mt-0 text-right"> <span>Min: <span class="font-mono font-semibold">{{ (l.minPrice || 0).toFixed(2) }}</span> SOL</span><br> <span>Max: <span class="font-mono font-semibold">{{ (l.maxPrice || 0).toFixed(2) }}</span> SOL</span> <button v-if="!l.notificationSent" @click="notifyBuyersAboutListing(l, true)" class="ml-2 text-xs text-blue-600 border border-blue-300 rounded px-2 py-1 hover:bg-blue-50"> <i class="fas fa-bell mr-1"></i> Notify </button> </div>
                   </li>
                 </ul>
                 </div>
               </div>
           </div>
         </div>
    </section>
    <section v-if="current==='farmerFunding'" class="max-w-3xl mx-auto mt-6">
         <div v-if="!bedrockIsAuthenticated || role !== 'farmer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Farmer to request funding.</p> </div>
         <div v-else>
            <h2 class="text-2xl font-bold text-green-700 mb-4"><i class="fas fa-money-bill-wave mr-2"></i>Request Funding for Your Farm</h2>
            <div class="bg-white rounded shadow-md p-6">
               <form @submit.prevent="createFundingRequest_V1">
               <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                   <div> <label class="block text-gray-600 mb-1 text-sm">Project Title</label> <input v-model.trim="fundingForm.title" class="w-full px-3 py-2 border rounded text-sm" required placeholder="e.g., Organic Tomato Expansion"> </div>
                   <div> <label class="block text-gray-600 mb-1 text-sm">Crop Type</label> <input v-model.trim="fundingForm.crop" class="w-full px-3 py-2 border rounded text-sm" required placeholder="e.g., Roma Tomatoes"> </div>
                   <div> <label class="block text-gray-600 mb-1 text-sm">Land Size (Acres)</label> <input type="number" v-model.number="fundingForm.acres" class="w-full px-3 py-2 border rounded text-sm" min="0.1" step="0.1" required placeholder="e.g., 5.5"> </div>
                   <div> <label class="block text-gray-600 mb-1 text-sm">Funding Required (SOL)</label> <input type="number" v-model.number="fundingForm.amount" class="w-full px-3 py-2 border rounded text-sm" min="1" step="0.1" required placeholder="e.g., 50"> </div>
                   <div> <label class="block text-gray-600 mb-1 text-sm">Growing Method</label> <select v-model="fundingForm.method" class="w-full px-3 py-2 border rounded bg-white text-sm" required> <option value="">Select method...</option> <option value="organic">Organic</option> <option value="conventional">Conventional</option> <option value="hydroponic">Hydroponic</option> <option value="aquaponic">Aquaponic</option> <option value="regenerative">Regenerative</option> </select> </div>
                   <div> <label class="block text-gray-600 mb-1 text-sm">Expected ROI (%)</label> <input type="number" v-model.number="fundingForm.roi" class="w-full px-3 py-2 border rounded text-sm" min="1" max="100" step="0.1" required placeholder="e.g., 15"> </div>
               </div>
               <div class="mb-4"> <label class="block text-gray-600 mb-1 text-sm">Select Video Evidence</label> <select v-model="fundingForm.cid" class="w-full px-3 py-2 border rounded bg-white mb-2 text-sm" required> <option value="" disabled>Select video...</option> <option v-for="vid in availableVideosForFunding" :key="vid.id" :value="vid.cid"> {{ vid.crop }} ({{ vid.location }}) - {{ vid.pesticideCompany || 'N/A' }} (CID: {{ vid.cid.substring(0,8) }}...) </option> <option v-if="farmerVideos.length > 0 && availableVideosForFunding.length === 0" disabled>No unlisted/unused videos available</option> <option v-if="farmerVideos.length === 0" disabled>No videos uploaded yet</option></select> <p v-if="farmerVideos.length === 0" class="text-xs text-red-500">You need to upload a video first via PestiVid.</p> <p v-if="farmerVideos.length > 0 && availableVideosForFunding.length === 0" class="text-xs text-yellow-600">All your 'For Funding' or 'General' videos are already used for funding or listings.</p> </div>
               <div class="mb-4"> <label class="block text-gray-600 mb-1 text-sm">Project Description</label> <textarea v-model.trim="fundingForm.description" class="w-full px-3 py-2 border rounded text-sm" rows="4" required placeholder="Describe your project, growing practices, and how funds will be used..."></textarea> </div>
               <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6"> <div> <label class="block text-gray-600 mb-1 text-sm">Timeline (Months)</label> <input type="number" v-model.number="fundingForm.timeline" class="w-full px-3 py-2 border rounded text-sm" min="1" max="36" step="1" required placeholder="How many months until harvest?"> </div> <div> <label class="block text-gray-600 mb-1 text-sm">Investor Share (%)</label> <input type="number" v-model.number="fundingForm.investorShare" class="w-full px-3 py-2 border rounded text-sm" min="1" max="80" step="0.1" required placeholder="Percentage of harvest profit for investors"> </div> </div>
               <button type="submit" class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded w-full" :disabled="!fundingForm.cid || fundingForm.acres === null || fundingForm.amount === null || fundingForm.timeline === null || fundingForm.roi === null || fundingForm.investorShare === null || !fundingForm.title.trim() || !fundingForm.crop.trim() || !fundingForm.method || !fundingForm.description.trim() || !bedrockIsAuthenticated || role !== 'farmer'"> <i class="fas fa-paper-plane mr-1"></i> Create Funding Request </button>
               </form>
               <div v-if="createdFundingRequest" class="bg-green-100 text-green-700 px-4 py-2 mt-4 rounded font-medium text-sm"> <i class="fas fa-check mr-1"></i> Funding request created and is now visible to investors! </div>
               <div class="mt-8">
               <h3 class="font-semibold mb-2 text-gray-700">Your Active Funding Requests</h3>
               <div v-if="farmerFundingRequests.length===0" class="text-gray-600 text-sm bg-gray-50 p-4 rounded text-center">You have no active funding requests.</div>
               <div v-else class="space-y-4">
                   <div v-for="req in farmerFundingRequests" :key="req.id" class="border rounded-lg overflow-hidden shadow-sm bg-white">
                   <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center p-4 bg-gray-50 border-b"> <h4 class="font-bold mb-2 sm:mb-0">{{ req.title }}</h4> <div class="flex items-center space-x-2"> <span :class="{'bg-yellow-100 text-yellow-800': req.status === 'pending', 'bg-green-100 text-green-800': req.status === 'funded', 'bg-blue-100 text-blue-800': req.status === 'partially_funded', 'bg-red-100 text-red-800': req.status === 'cancelled'}" class="px-2 py-1 rounded text-xs font-medium"> {{ req.status === 'pending' ? 'Pending' : req.status === 'funded' ? 'Fully Funded' : (req.status === 'partially_funded' ? 'Partially Funded' : (req.status === 'cancelled' ? 'Cancelled' : req.status)) }} </span> </div> </div>
                   <div class="p-4">
                       <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4 text-sm"> <div> <div class="text-xs text-gray-500">Crop</div> <div>{{ req.crop }}</div> </div> <div> <div class="text-xs text-gray-500">Land Size</div> <div>{{ (req.acres || 0).toFixed(1) }} acres</div> </div> <div> <div class="text-xs text-gray-500">Required</div> <div class="font-mono">{{ (req.amount || 0).toFixed(2) }} SOL</div> </div> <div> <div class="text-xs text-gray-500">Investor Share</div> <div class="font-mono">{{ (req.investorShare || 0).toFixed(1) }}%</div> </div> </div>
                       <div class="mb-4"> <div class="text-xs text-gray-500 mb-1">Funding Progress</div> <div class="progress-bar"> <div class="progress-fill bg-green-500" :style="{width: fundingProgressPercent(req) + '%'}"></div> </div> <div class="flex justify-between text-xs mt-1"> <span>{{ (req.fundedAmount || 0).toFixed(2) }} SOL raised</span> <span>{{ fundingProgressPercent(req) }}% Complete</span> </div> </div>
                       <div v-if="req.fundedAmount > 0 && req.investors && req.investors.length > 0" class="mb-4"> <div class="text-xs text-gray-500 mb-2">Investors ({{req.investors.length}})</div> <div class="text-sm max-h-24 overflow-y-auto border rounded p-2 bg-gray-50 space-y-1"> <div v-for="investor in req.investors" :key="investor.id || investor.txHash || investor.investorId" class="flex justify-between items-center py-1 text-xs"> <span><i class="fas fa-user text-gray-400 mr-1"></i>{{ investor.investorId ? (getFarmerDisplayIdentifier(investor.investorId, 10)) : 'Investor' }}</span> <span class="font-mono bg-blue-100 text-blue-800 px-1 rounded">{{ (investor.amount || 0).toFixed(2) }} SOL</span> </div> </div> </div>
                       <div class="flex justify-end mt-4"> <button v-if="req.status !== 'funded' && req.status !== 'cancelled'" class="px-3 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200" @click="cancelFundingRequest_V1(req.id)"> <i class="fas fa-times mr-1"></i>Cancel Request </button> <span v-if="req.status === 'funded'" class="text-xs text-green-600"><i class="fas fa-check-circle mr-1"></i>Fully Funded!</span> <span v-if="req.status === 'cancelled'" class="text-xs text-red-600"><i class="fas fa-times-circle mr-1"></i>Cancelled</span> </div>
                   </div>
                   </div>
               </div>
               </div>
            </div>
    </section>
    <section v-if="current==='buyerAgriSell'" class="max-w-6xl mx-auto mt-6">
         <div v-if="!bedrockIsAuthenticated || role !== 'buyer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Buyer to browse the marketplace.</p> </div>
         <div v-else>
            <h2 class="text-2xl font-bold text-green-700 mb-3"><i class="fas fa-shopping-basket mr-2"></i>AgriSell: Marketplace</h2>
            <div class="bg-white rounded shadow-md p-6 mb-7">
              <div class="flex flex-col md:flex-row md:items-end gap-5">
                <div class="w-full md:w-48"> <label class="block text-gray-600 text-sm">Crop Type</label> <select v-model="buyerFilters.crop" class="w-full px-2 py-1 border rounded bg-white text-sm"> <option value="">All</option> <option v-for="c in uniqueCrops" :key="c">{{c}}</option> </select> </div>
                <div class="flex-1"> <label class="block text-gray-600 text-sm">Location</label> <input v-model.trim="buyerFilters.location" class="w-full px-2 py-1 border rounded text-sm" placeholder="Search by location..."> </div>
                <div class="flex-1"> <label class="block text-gray-600 text-sm">Pesticide Co.</label> <input v-model.trim="buyerFilters.pesticideCompany" class="w-full px-2 py-1 border rounded text-sm" placeholder="Search by pesticide company..."> </div>
                <button type="button" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-1 rounded text-sm mt-2 md:mt-0" @click="resetBuyerFilters"> <i class="fas fa-undo mr-1"></i> Reset Filters </button>
              </div>
            </div>
            <div v-if="filteredListings.length === 0" class="text-gray-600 bg-gray-50 p-8 text-center rounded"> <i class="fas fa-search text-4xl text-gray-400 mb-3"></i><br> No listings found matching your criteria. Try adjusting your filters. </div>
            <div v-else class="grid gap-8 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
              <div v-for="l in filteredListings" :key="l.id" class="bg-white rounded shadow p-4 flex flex-col relative">
                  <div v-if="l.isNew" class="new-badge">NEW</div>
                <div class="mb-3 flex justify-center"> <video :src="ipfsUrl(l.cid)" controls playsinline webkit-playsinline class="rounded w-full max-h-52 bg-black object-cover"></video> </div>
                <div class="mb-1 font-bold text-lg">{{ l.crop }}</div>
                <div class="text-xs text-gray-500 mb-1">Location: <span class="font-mono">{{ l.location }}</span></div>
                <div class="text-xs text-gray-500 mb-1">Pesticide: <span class="font-mono">{{ l.pesticide }}</span></div>
                <div class="text-xs text-gray-500 mb-2">Pesticide Co.: <span class="font-mono">{{ l.pesticideCompany || 'N/A' }}</span></div>
                <div class="text-sm my-2">Price Range: <br><span class="font-mono text-base font-semibold">{{ (l.minPrice || 0).toFixed(2) }}</span> - <span class="ml-1 font-mono font-semibold">{{ (l.maxPrice || 0).toFixed(2) }}</span> SOL </div>
                <div class="flex items-center text-xs text-gray-600 mb-2"> <span class="mr-1">Sold by: {{ getSellerDisplayIdentifier(l.farmerWallet) }}</span> <button @click="showFarmerProfile(l.farmerWallet)" class="text-blue-500 hover:text-blue-700 focus:outline-none" title="View Farmer Info"> <i class="fas fa-info-circle"></i> </button> </div>
                <button class="mt-auto bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded text-sm" @click="buyListing(l)" :disabled="!bedrockIsAuthenticated || role !== 'buyer' || currentUserIdentifier === l.farmerWallet"> <i class="fas fa-shopping-cart mr-1"></i> {{ currentUserIdentifier === l.farmerWallet ? 'Your Listing' : (!bedrockIsAuthenticated || role !== 'buyer' ? 'Login as Buyer to Purchase' : 'Initiate Purchase') }} </button>
                <button @click="startOrGoToConversation(l.farmerWallet)" v-if="bedrockIsAuthenticated && currentUserIdentifier !== l.farmerWallet" class="mt-2 text-xs text-blue-600 hover:text-blue-700 border border-blue-400 rounded-full px-3 py-1 hover:bg-blue-50 flex items-center justify-center"> <i class="fas fa-envelope mr-1"></i> Message Seller </button>
              </div>
            </div>
         </div>
    </section>
    <section v-if="current==='investorProjects'" class="max-w-6xl mx-auto mt-6">
        <div v-if="!bedrockIsAuthenticated || role !== 'investor'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as an Investor to view projects.</p> </div>
        <div v-else>
          <h2 class="text-2xl font-bold text-green-700 mb-3"><i class="fas fa-project-diagram mr-2"></i>Investment Opportunities</h2>
          <div class="bg-white rounded shadow-md p-6 mb-7">
            <div class="flex flex-col md:flex-row md:items-end gap-5">
              <div class="w-full md:w-48"> <label class="block text-gray-600 text-sm">Crop Type</label> <select v-model="investorFilters.crop" class="w-full px-2 py-1 border rounded bg-white text-sm"> <option value="">All Crops</option> <option v-for="c in uniqueFundingCrops" :key="c">{{c}}</option> </select> </div>
              <div class="w-full md:w-48"> <label class="block text-gray-600 text-sm">Growing Method</label> <select v-model="investorFilters.method" class="w-full px-2 py-1 border rounded bg-white text-sm"> <option value="">All Methods</option> <option value="organic">Organic</option> <option value="conventional">Conventional</option> <option value="hydroponic">Hydroponic</option> <option value="aquaponic">Aquaponic</option> <option value="regenerative">Regenerative</option> </select> </div>
              <div class="w-full md:w-48"> <label class="block text-gray-600 text-sm">Min ROI (%)</label> <input type="number" v-model.number="investorFilters.minRoi" class="w-full px-2 py-1 border rounded text-sm" min="1" step="0.1" placeholder="e.g., 10"> </div>
              <div class="w-full md:w-48"> <label class="block text-gray-600 text-sm">Max Funding Needed (SOL)</label> <input type="number" v-model.number="investorFilters.maxAmount" class="w-full px-2 py-1 border rounded text-sm" min="1" step="0.1" placeholder="e.g., 100"> </div>
              <button type="button" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-1 rounded text-sm mt-2 md:mt-0" @click="resetInvestorFilters"> <i class="fas fa-undo mr-1"></i> Reset Filters </button>
            </div>
          </div>
          <div v-if="filteredFundingRequests.length === 0" class="text-gray-600 bg-gray-50 p-8 text-center rounded"> <i class="fas fa-search text-4xl text-gray-400 mb-3"></i><br> No projects found matching your criteria. Try adjusting your filters. </div>
          <div v-else class="grid gap-6 grid-cols-1 lg:grid-cols-2">
            <div v-for="project in filteredFundingRequests" :key="project.id" class="bg-white rounded-lg shadow overflow-hidden relative">
              <div v-if="project.isNew" class="new-badge">NEW</div>
              <div class="p-5 bg-gray-50 border-b flex flex-col sm:flex-row justify-between items-start sm:items-center"> <h3 class="font-bold text-lg text-green-800 mb-2 sm:mb-0">{{ project.title }}</h3> <span :class="{'bg-yellow-100 text-yellow-800': project.status === 'pending', 'bg-green-100 text-green-800': project.status === 'funded', 'bg-blue-100 text-blue-800': project.status === 'partially_funded'}" class="px-2 py-1 rounded text-xs font-medium self-start sm:self-center"> {{ project.status === 'pending' ? 'Seeking Funding' : project.status === 'funded' ? 'Fully Funded' : 'Partial Funding' }} </span> </div>
              <div class="p-5">
                <div class="flex flex-col md:flex-row gap-6">
                  <div class="md:w-1/3">
                    <video :src="ipfsUrl(project.cid)" controls playsinline webkit-playsinline class="rounded w-full h-40 object-cover bg-black mb-3"></video>
                    <div class="grid grid-cols-2 gap-2 text-sm"> <div> <div class="text-xs text-gray-500">Farmer</div> <div class="font-medium truncate flex items-center"> <span>{{ getFarmerDisplayIdentifier(project.farmerWallet) }}</span> <button @click="showFarmerProfile(project.farmerWallet)" class="ml-2 text-blue-500 hover:text-blue-700 text-xs focus:outline-none" title="View Farmer Info"> <i class="fas fa-info-circle"></i> </button> <button @click="startOrGoToConversation(project.farmerWallet)" v-if="bedrockIsAuthenticated && currentUserIdentifier !== project.farmerWallet" class="ml-2 text-green-600 hover:text-green-700 text-xs focus:outline-none" title="Message Farmer"> <i class="fas fa-envelope"></i> </button> </div> </div> <div> <div class="text-xs text-gray-500">Land Size</div> <div class="font-medium">{{ (project.acres || 0).toFixed(1) }} acres</div> </div> <div> <div class="text-xs text-gray-500">Timeline</div> <div class="font-medium">{{ project.timeline }} months</div> </div> <div> <div class="text-xs text-gray-500">Expected ROI</div> <div class="font-medium text-green-700">{{ (project.roi || 0).toFixed(1) }}%</div> </div> </div>
                    <button @click="startOrGoToConversation(project.farmerWallet)" v-if="bedrockIsAuthenticated && currentUserIdentifier !== project.farmerWallet" class="mt-3 w-full text-xs text-blue-600 hover:text-blue-700 border border-blue-400 rounded-full px-3 py-1 hover:bg-blue-50 flex items-center justify-center"> <i class="fas fa-envelope mr-1"></i> Message Farmer </button>
                  </div>
                  <div class="md:w-2/3">
                    <div class="mb-4"> <div class="text-sm font-medium mb-1">{{ project.crop }} ({{ project.method }})</div> <p class="text-sm text-gray-700 max-h-20 overflow-y-auto">{{ project.description }}</p> </div>
                    <div class="mb-4"> <div class="text-xs text-gray-500 mb-1">Funding Progress</div> <div class="progress-bar"> <div class="progress-fill bg-green-500" :style="{width: fundingProgressPercent(project) + '%'}"></div> </div> <div class="flex justify-between text-xs mt-1"> <span>{{ (project.fundedAmount || 0).toFixed(2) }} / {{ (project.amount || 0).toFixed(2) }} SOL</span> <span>{{ fundingProgressPercent(project) }}% Complete</span> </div> </div>
                    <div v-if="project.updates && project.updates.length > 0" class="mb-4"> <h4 class="text-sm font-semibold text-gray-700 mb-2">Recent Farmer Updates</h4> <div class="project-updates-list text-xs" style="max-height: 70px;"> <div v-for="update in project.updates.slice().reverse().slice(0,2)" :key="update.id" class="project-update-item"> <span class="font-medium text-gray-500">{{ update.date }}:</span> {{ update.text }} </div> </div> </div>
                    <div class="mb-4"> <div class="flex justify-between items-center mb-2"> <div class="text-sm font-medium">Investment Terms</div> <div class="text-xs text-gray-500">Investor Share: {{ (project.investorShare || 0).toFixed(1) }}% of profit</div> </div> <div class="p-3 bg-yellow-50 rounded text-sm border border-yellow-200"> <p>Invest to receive {{ (project.investorShare || 0).toFixed(1) }}% of the profits, proportional to your investment amount. Expected return is {{ (project.roi || 0).toFixed(1) }}% over {{ project.timeline }} months (estimated).</p> </div> </div>
                    <div class="flex flex-col sm:flex-row justify-between items-center mt-4 pt-4 border-t"> <div class="mb-3 sm:mb-0"> <label :for="'investment-amount-'+project.id" class="text-xs text-gray-500 block mb-1">Your Investment (SOL)</label> <input v-model.number="investmentAmounts[project.id]" type="number" :id="'investment-amount-'+project.id" class="px-3 py-1 border rounded w-full sm:w-32 text-sm" min="0.01" :max="maxInvestmentAmount(project)" step="0.01" :disabled="project.status === 'funded' || project.status === 'harvested' || project.status === 'cancelled' || !bedrockIsAuthenticated || role !== 'investor'" :placeholder="maxInvestmentAmount(project) > 0 ? `Max ${maxInvestmentAmount(project).toFixed(2)}` : 'Fully Funded'"> </div> <button @click="investInProject(project)" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm w-full sm:w-auto" :disabled="project.status === 'funded' || project.status === 'harvested' || project.status === 'cancelled' || !bedrockIsAuthenticated || role !== 'investor' || investmentAmounts[project.id] === null || investmentAmounts[project.id] <= 0 || investmentAmounts[project.id] > maxInvestmentAmount(project) + 0.00001"> <i class="fas fa-coins mr-1"></i> {{ project.status === 'funded' ? 'Fully Funded' : (project.status === 'harvested' ? 'Harvested' : (project.status === 'cancelled' ? 'Cancelled' : (!bedrockIsAuthenticated || role !== 'investor' ? 'Login as Investor' : 'Invest Now'))) }} </button> </div>
                    <div v-if="investmentErrors[project.id]" class="text-red-500 text-xs mt-2">{{ investmentErrors[project.id] }}</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div v-if="filteredFundingRequests.length === 0" class="bg-gray-50 p-8 text-center rounded-lg mt-4"> <i class="fas fa-seedling text-gray-300 text-4xl mb-3"></i> <h3 class="text-gray-600 text-lg mb-2">No Projects Found</h3> <p class="text-gray-500">Try adjusting your filters or check back later for new investment opportunities.</p> </div>
        </div>
    </section>
    <section v-if="current==='investorPortfolio'" class="max-w-6xl mx-auto mt-6">
         <div v-if="!bedrockIsAuthenticated || role !== 'investor'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as an Investor to view your portfolio.</p> </div>
         <div v-else>
            <h2 class="text-2xl font-bold text-green-700 mb-4"><i class="fas fa-chart-pie mr-2"></i>Investment Portfolio</h2>
            <div class="bg-white rounded-lg shadow p-6 mb-8">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">Portfolio Overview</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-6"> <div class="mb-4 md:mb-0"> <div class="text-xs text-gray-500">Total Invested</div> <div class="text-2xl font-bold text-green-700">{{ totalInvestedAmount }} SOL</div> </div> <div> <div class="text-xs text-gray-500">Active Projects</div> <div class="text-xl font-bold">{{ investorActiveProjects }}</div> </div> <div> <div class="text-xs text-gray-500">Completed</div> <div class="text-xl font-bold">{{ investorCompletedProjects }}</div> </div> <div> <div class="text-xs text-gray-500">Avg. ROI (Est.)</div> <div class="text-xl font-bold text-green-700">{{ investorAvgRoi }}%</div> </div> </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden mb-8">
                <div class="px-6 py-4 bg-gray-50 border-b"> <h3 class="text-lg font-semibold text-gray-800">Your Active Investments</h3> </div>
                <div v-if="investorInvestments.length === 0" class="p-8 text-center"> <i class="fas fa-chart-line text-gray-300 text-4xl mb-3"></i> <h4 class="text-gray-600 text-lg mb-2">No Active Investments</h4> <p class="text-gray-500 mb-4">You haven't invested in any agricultural projects yet.</p> <button @click="switchPage('investorProjects')" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm"> <i class="fas fa-search mr-1"></i>Browse Projects </button> </div>
                <div v-else class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50"> <tr> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Project</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Farmer</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Invested (SOL)</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Progress</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expected Return (Est. SOL)</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Details</th> </tr> </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                    <tr v-for="investment in investorInvestments" :key="investment.id">
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm font-medium text-gray-900">{{ investment.projectTitle }}</div> <div class="text-xs text-gray-500">{{ investment.crop }}</div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm text-gray-900">{{ getFarmerDisplayIdentifier(investment.farmerWallet, 10) }}</div> <button @click="showFarmerProfile(investment.farmerWallet)" class="text-blue-500 hover:text-blue-700 text-xs focus:outline-none mr-2" title="View Farmer Info"> <i class="fas fa-info-circle"></i> </button> <button @click="startOrGoToConversation(investment.farmerWallet)" v-if="bedrockIsAuthenticated && currentUserIdentifier !== investment.investorWallet" class="text-green-600 hover:text-green-700 text-xs focus:outline-none" title="Message Farmer"> <i class="fas fa-envelope mr-1"></i>Message </button> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm text-gray-900 font-mono">{{ (investment.amount || 0).toFixed(2) }}</div> <div class="text-xs text-gray-500">{{ investment.investmentDate }}</div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="w-24 bg-gray-200 rounded-full h-2.5"> <div class="bg-green-600 h-2.5 rounded-full" :style="{width: (investment.progress || 0) + '%'}"></div> </div> <div class="text-xs text-gray-500 mt-1">{{ (investment.progress || 0).toFixed(0) }}% Complete</div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm text-gray-900 font-mono">{{ calculateExpectedReturn(investment) }}</div> <div class="text-xs text-gray-500">{{ (investment.roi || 0).toFixed(1) }}% ROI</div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <span :class="{ 'px-2 inline-flex text-xs leading-5 font-semibold rounded-full': true, 'bg-blue-100 text-blue-800': investment.status === 'active' || investment.status === 'partially_funded', 'bg-green-100 text-green-800': investment.status === 'harvested' || investment.status === 'funded', 'bg-yellow-100 text-yellow-800': investment.status === 'growing', 'bg-red-100 text-red-800': investment.status === 'cancelled' }"> {{ investment.status === 'active' || investment.status === 'partially_funded' ? 'Active' : investment.status === 'harvested' ? 'Harvested' : (investment.status === 'growing' ? 'Growing' : (investment.status === 'cancelled' ? 'Cancelled' : investment.status)) }} </span> </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-blue-600"> <a href="#" @click.prevent="viewInvestmentDetails(investment)" class="hover:underline">View</a> </td>
                    </tr>
                    </tbody>
                </table>
                </div>
            </div>
            <div class="bg-white rounded-lg shadow overflow-hidden">
                <div class="px-6 py-4 bg-gray-50 border-b flex justify-between items-center"> <h3 class="text-lg font-semibold text-gray-800">Platform Transaction History (Simulated)</h3> <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded-full flex items-center"> <svg class="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 16 15"><path d="m7.81 0-1.78 3.69L1.88 4.2l2.92 2.52L4.04 10 7.8 7.97 11.55 10l-.77-3.28 2.92 2.52-4.15-.51L7.82 0h-.01Zm0 15-1.78-3.69-4.15-.51 2.92-2.52L4.04 5 7.8 7.03 11.55 5l-.77 3.28 2.92 2.52-4.15-.51L7.82 15h-.01Z"></path></svg> PestiVid Platform (Simulated Ledger) </span> </div>
                <div v-if="investorTransactions.length === 0" class="p-8 text-center"> <i class="fas fa-cubes text-gray-300 text-4xl mb-3"></i> <h4 class="text-gray-600 text-lg mb-2">No Transactions Yet</h4> <p class="text-gray-500">Your investment and payout transactions on the platform will appear here.</p> </div>
                <div v-else class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50"> <tr> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Transaction ID</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount (SOL)</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th> <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th> </tr> </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                    <tr v-for="tx in investorTransactions" :key="tx.id">
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="flex items-center"> <div class="text-sm font-mono text-gray-900 truncate max-w-[150px] sm:max-w-[250px]" :title="tx.txHash">{{ tx.txHash.substring(0,10) }}...{{ tx.txHash.substring(tx.txHash.length-10) }}</div> <a :href="solanaExplorerUrl(tx.txHash)" target="_blank" class="ml-1 text-blue-500 hover:text-blue-700" title="View on Solana Explorer (Demo Link)"> <i class="fas fa-external-link-alt text-xs"></i> </a> </div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <span :class="{ 'px-2 inline-flex text-xs leading-5 font-semibold rounded-full': true, 'bg-green-100 text-green-800': tx.type === 'investment', 'bg-blue-100 text-blue-800': tx.type === 'payout', 'bg-red-100 text-red-800': tx.type === 'refund' }"> {{ tx.type === 'investment' ? 'Investment' : (tx.type === 'payout' ? 'Harvest Payout' : 'Refund') }} </span> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm font-mono text-gray-900">{{ (tx.amount || 0).toFixed(2) }}</div> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800"> Confirmed (Sim.) </span> </td>
                        <td class="px-6 py-4 whitespace-nowrap"> <div class="text-sm text-gray-900">{{ tx.date }}</div> </td>
                    </tr>
                    </tbody>
                </table>
                </div>
            </div>
         </div>
    </section>
     <section v-if="current==='plantRecomendation'" class="max-w-3xl mx-auto mt-6">
      <h2 class="text-2xl font-bold text-green-700 mb-4"><i class="fas fa-leaf mr-2"></i>Plant Disease Detection & Recommendation</h2>
       <div v-if="!bedrockIsAuthenticated || role !== 'farmer'" class="text-center p-10 bg-white rounded-lg shadow"> <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i> <p class="text-xl text-gray-700">Please log in as a Farmer to access Plant Recommendation.</p> </div>
      <div v-else class="bg-white rounded shadow-md p-6 space-y-6">
        <p class="text-sm text-gray-600">Upload an image of an affected plant. Gemini AI will attempt to identify the plant, detect diseases, and suggest treatments.</p>

        <div v-if="geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE' || geminiApiKey.includes('YOUR_')" class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4" role="alert">
          <p class="font-bold">Developer Note:</p>
          <p class="text-sm">The Gemini API key is currently embedded in the client-side code for this demo. In a production environment, this is insecure and should be handled via a backend proxy. Replace <code>'YOUR_GEMINI_API_KEY_HERE'</code> with your key.</p>
        </div>

        <div>
          <label class="block text-gray-600 mb-1 text-sm">Upload Plant Image</label>
          <input type="file" @change="handlePlantImageUpload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 file:text-green-700 hover:file:bg-green-100">
        </div>

        <div v-if="plantImageUrl" class="mt-4">
          <h4 class="text-md font-semibold text-gray-700 mb-2">Image Preview:</h4>
          <img :src="plantImageUrl" alt="Plant Preview" class="max-w-xs md:max-sm rounded-md border shadow mx-auto">
        </div>

        <button @click="analyzePlant" :disabled="!plantImageFile || analysisInProgress || geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE' || geminiApiKey.includes('YOUR_')" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded text-sm flex items-center justify-center" :class="{'opacity-50 cursor-not-allowed': !plantImageFile || analysisInProgress || geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE' || geminiApiKey.includes('YOUR_')}">
          <i :class="analysisInProgress ? 'fas fa-spinner fa-spin' : 'fas fa-search-plus'" class="mr-2"></i>
          {{ analysisInProgress ? 'Analyzing...' : (geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE' || geminiApiKey.includes('YOUR_') ? 'Add Gemini API Key' : 'Analyze Plant with Gemini AI') }}
        </button>

        <div v-if="analysisErrorText" class="mt-4 bg-red-100 border border-red-300 text-red-700 px-4 py-3 rounded text-sm">
          <p class="font-bold">Analysis Error:</p>
          <p>{{ analysisErrorText }}</p>
        </div>

        <div v-if="analysisResultText && !analysisInProgress && !analysisErrorText" class="mt-6 border-t pt-6 space-y-4">
          <h3 class="text-xl font-semibold text-green-700">Analysis Results:</h3>
          <div>
            <p class="text-sm font-medium text-gray-500">Identified Plant:</p>
            <p class="text-lg text-gray-800">{{ parsedAnalysis.plantName || 'Could not identify plant.' }}</p>
          </div>
          <div>
            <p class="text-sm font-medium text-gray-500">Detected Disease:</p>
            <p class="text-lg text-gray-800 font-semibold" :class="{'text-red-600': parsedAnalysis.diseaseName && parsedAnalysis.diseaseName.toLowerCase() !== 'healthy' && parsedAnalysis.diseaseName.toLowerCase() !== 'not apparent' && parsedAnalysis.diseaseName.toLowerCase() !== 'unknown' && parsedAnalysis.diseaseName.trim() !== '-', 'text-green-600': parsedAnalysis.diseaseName && (parsedAnalysis.diseaseName.toLowerCase() === 'healthy' || parsedAnalysis.diseaseName.toLowerCase() === 'not apparent')}">
              {{ parsedAnalysis.diseaseName || 'Could not determine disease.' }}
            </p>
          </div>
          <div>
            <p class="text-sm font-medium text-gray-500">Recommended Treatment / Pesticides:</p>
            <p class="text-md text-gray-700 whitespace-pre-wrap">{{ parsedAnalysis.treatmentRecommended || 'No specific treatment recommended.' }}</p>
          </div>
           <div v-if="analysisResultText && (!parsedAnalysis.plantName || parsedAnalysis.plantName === 'Unknown' || parsedAnalysis.plantName.trim() === '-' || !parsedAnalysis.diseaseName || parsedAnalysis.diseaseName === 'Unknown' || parsedAnalysis.diseaseName.trim() === '-')" class="mt-4 bg-gray-50 p-3 rounded border text-xs">
                <p class="font-semibold mb-1">Raw Gemini Output (for debugging if parsing failed):</p>
                <pre class="whitespace-pre-wrap overflow-x-auto">{{ analysisResultText }}</pre>
            </div>
        </div>
      </div>
    </section>

     <!-- Messaging Section -->
    <section v-if="current === 'messaging'" class="max-w-4xl mx-auto mt-6">
        <div v-if="!bedrockIsAuthenticated || !currentUserIdentifier" class="text-center p-10 bg-white rounded-lg shadow">
            <i class="fas fa-exclamation-circle text-3xl text-yellow-500 mb-4"></i>
            <p class="text-xl text-gray-700">Please log in to access messages.</p>
        </div>
        <div v-else class="bg-white rounded-lg shadow-md overflow-hidden">
            <div class="flex h-[70vh]">
                <!-- Conversation List (Left Pane) -->
                <div class="w-1/3 md:w-1/4 border-r overflow-y-auto">
                    <div class="p-4 bg-gray-50 border-b">
                        <h3 class="font-semibold text-lg text-gray-800">Conversations</h3>
                    </div>
                    <div class="space-y-1 py-2">
                         <div v-if="userConversations.length === 0" class="text-center text-gray-500 text-sm py-4 px-2">
                             No conversations yet. You can start one from a marketplace listing or project page.
                         </div>
                        <div v-for="conv in userConversations" :key="conv.id"
                             @click="selectConversation(conv.id)"
                             class="flex items-center p-3 cursor-pointer hover:bg-gray-100 transition"
                             :class="{'bg-green-100 hover:bg-green-200 border-l-4 border-green-500': activeConversationId === conv.id}">
                            <div class="w-10 h-10 rounded-full bg-green-200 text-green-700 flex items-center justify-center font-bold text-sm mr-3 flex-shrink-0">
                                {{ getOtherParticipantInitial(conv) }}
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="flex justify-between items-center mb-1">
                                    <span class="font-semibold text-sm truncate">{{ getOtherParticipantDisplayAddress(conv) }}</span>
                                     <span v-if="conv.unreadCount > 0" class="mobile-notification-badge">{{ conv.unreadCount }}</span>
                                </div>
                                <p class="text-xs text-gray-600 truncate">
                                    {{ conv.lastMessageSnippet }}
                                </p>
                                <p class="text-xs text-gray-400 mt-1">{{ formatTimestamp(conv.lastMessageTimestamp, true) }}</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Message View (Right Pane) -->
                <div class="w-2/3 md:w-3/4 flex flex-col">
                    <div v-if="activeConversationId" class="p-4 bg-gray-50 border-b flex justify-between items-center sticky top-0 z-10">
                        <h3 class="font-semibold text-lg text-gray-800 truncate">{{ activeConversationPartnerDisplayAddress }}</h3>
                        <!-- Close chat button for mobile? -->
                        <button @click="activeConversationId = null" class="md:hidden text-gray-500 hover:text-red-500"><i class="fas fa-times"></i></button>
                    </div>
                    <div v-else class="p-4 bg-gray-50 border-b flex justify-center items-center sticky top-0 z-10 h-[60px]">
                         <h3 class="font-semibold text-lg text-gray-600">Select a Conversation</h3>
                    </div>


                    <div v-if="activeConversationId" ref="messageContainer" class="flex-1 p-4 overflow-y-auto space-y-4 message-view-container">
                        <div v-for="msg in currentMessages" :key="msg.id"
                             :class="{'flex justify-end': msg.sender === currentUserIdentifier, 'flex justify-start': msg.sender !== currentUserIdentifier}">
                            <div :class="{'bg-green-600 text-white rounded-bl-xl': msg.sender === currentUserIdentifier, 'bg-gray-200 text-gray-800 rounded-br-xl': msg.sender !== currentUserIdentifier}"
                                 class="max-w-sm px-4 py-2 rounded-xl shadow-sm break-words">
                                <div class="text-sm">{{ msg.text }}</div>
                                <div class="text-right text-xs mt-1" :class="{'text-green-200': msg.sender === currentUserIdentifier, 'text-gray-500': msg.sender !== currentUserIdentifier}">
                                    {{ formatTimestamp(msg.timestamp) }}
                                </div>
                            </div>
                        </div>
                         <div v-if="currentMessages.length === 0" class="text-center text-gray-500 text-sm italic py-10">Start of conversation.</div>
                    </div>
                     <div v-else class="flex-1 flex justify-center items-center text-gray-500 italic">
                        <p>No conversation selected.</p>
                    </div>

                    <div v-if="activeConversationId" class="p-4 border-t bg-white flex items-center sticky bottom-0 z-10">
                        <input v-model.trim="messageInputText" @keyup.enter="sendMessage" type="text" placeholder="Type a message..." class="flex-1 px-4 py-2 border rounded-full mr-3 focus:outline-none focus:ring-2 focus:ring-green-500 text-sm">
                        <button @click="sendMessage" :disabled="!messageInputText.trim()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-full disabled:opacity-50 disabled:cursor-not-allowed flex items-center">
                            <i class="fas fa-paper-plane mr-1"></i> Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </section>


    <!-- Modals (Purchase Video, Buy Listing, Investment Details, Farmer Profile) -->
     <!-- Purchase Video Modal -->
    <div v-if="selectedPurchase && showPurchaseVideo" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
      <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full modal-scrollable">
        <div class="p-4 border-b flex justify-between items-center sticky top-0 bg-white z-10"> <h3 class="font-bold text-lg text-green-700">{{ selectedPurchase.crop }} - Purchase Verification</h3> <button @click="showPurchaseVideo = false" class="text-gray-500 hover:text-gray-700"> <i class="fas fa-times"></i> </button> </div>
        <div class="p-4"> <video :src="ipfsUrl(selectedPurchase.cid)" controls playsinline webkit-playsinline class="w-full rounded bg-black mb-4"></video> <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm"> <div> <p class="text-gray-600">Location</p> <p class="font-medium">{{ selectedPurchase.location }}</p> </div> <div> <p class="text-gray-600">Pesticide Used</p> <p class="font-medium">{{ selectedPurchase.pesticide }}</p> </div> <div> <p class="text-gray-600">Pesticide Company</p> <p class="font-medium">{{ selectedPurchase.pesticideCompany || 'N/A' }}</p> </div> <div> <p class="text-gray-600">Purchase Price</p> <p class="font-medium font-mono">{{ (selectedPurchase.price || 0).toFixed(2) }} SOL</p> </div> <div> <p class="text-gray-600">Purchase Date</p> <p class="font-medium">{{ selectedPurchase.date }}</p> </div> <div> <p class="text-gray-600">Seller Identifier</p> <p class="font-medium font-mono text-xs break-all">{{ selectedPurchase.farmerWallet }}</p> </div> </div> <div class="mt-4 bg-gray-100 p-3 rounded text-xs border"> <p class="font-bold mb-1">Platform Verification (Simulated):</p> <p class="font-mono break-all mb-1">IPFS CID: {{ selectedPurchase.cid }} <a :href="ipfsUrl(selectedPurchase.cid)" target="_blank" class="text-blue-600 hover:underline ml-2">View on IPFS Gateway <i class="fas fa-external-link-alt text-xs ml-1"></i></a></p> <p class="font-mono break-all">Simulated Tx: {{ selectedPurchase.txHash }} <a :href="solanaExplorerUrl(selectedPurchase.txHash)" target="_blank" class="text-blue-500 hover:text-blue-700 ml-2"><i class="fas fa-external-link-alt text-xs"></i> View (Demo Link)</a> </p> <p class="mt-1 text-gray-500">Video evidence on IPFS, linked on PestiVid platform (Simulated Ledger).</p> </div> </div>
        <div class="bg-gray-50 p-4 flex justify-end rounded-b-lg sticky bottom-0 border-t"> <button @click="showPurchaseVideo = false" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded text-sm"> Close </button> </div>
      </div>
    </div>
    <!-- Buy Listing Modal -->
    <div v-if="showBuyModal && selectedListing" class="fixed inset-0 z-50 bg-black bg-opacity-60 flex justify-center items-center p-4">
      <div class="bg-white rounded shadow-lg w-full max-w-sm p-6 relative mx-2 modal-scrollable">
        <button class="absolute top-2 right-2 text-gray-400 hover:text-red-500" @click="closeBuyModal"><i class="fas fa-times"></i></button>
        <h3 class="font-bold text-green-700 text-lg mb-3">Purchase Crop Batch</h3>
        <video :src="ipfsUrl(selectedListing.cid)" controls playsinline webkit-playsinline class="rounded w-full mb-3 bg-black"></video>
        <div class="mb-1 font-bold">{{ selectedListing.crop }}</div> <div class="text-xs text-gray-600 mb-1">Location: <span class="font-mono">{{ selectedListing.location }}</span></div> <div class="text-xs text-gray-500 mb-1">Pesticide: <span class="font-mono">{{ selectedListing.pesticide }}</span></div> <div class="text-xs text-gray-500 mb-2">Pesticide Co.: <span class="font-mono">{{ selectedListing.pesticideCompany || 'N/A' }}</span></div> <div class="text-sm my-2">Price Range: <br><span class="font-mono text-base font-semibold">{{ (selectedListing.minPrice || 0).toFixed(2) }}</span> - <span class="ml-1 font-mono font-semibold">{{ (selectedListing.maxPrice || 0).toFixed(2) }}</span> SOL </div>
        <form @submit.prevent="processPurchase"> <label class="text-sm block text-gray-600 mb-1">Your Offer (SOL)</label> <input type="number" v-model.number="purchaseAmount" :min="selectedListing.minPrice" :max="selectedListing.maxPrice" step="0.01" required :placeholder="`Enter amount (${(selectedListing.minPrice || 0).toFixed(2)}-${(selectedListing.maxPrice || 0).toFixed(2)})`" class="w-full px-3 py-2 border rounded mb-3 text-sm"> <button type="submit" class="bg-green-600 hover:bg-green-700 text-white w-full py-2 rounded text-sm" :disabled="!bedrockIsAuthenticated || role !== 'buyer' || purchaseAmount === null || purchaseAmount < (selectedListing.minPrice || 0) || purchaseAmount > (selectedListing.maxPrice || 0)"> <i :class="purchaseStatus.includes('Processing') ? 'fas fa-spinner fa-spin' : 'fas fa-check'" class="mr-1"></i>Confirm Purchase (Simulated) </button> </form>
        <div v-if="purchaseStatus" class="text-green-700 font-semibold mt-3 text-sm bg-green-50 p-2 rounded border border-green-200">{{purchaseStatus}}</div> <div v-if="purchaseError" class="text-red-600 font-semibold mt-3 text-sm bg-red-50 p-2 rounded border border-red-200">{{purchaseError}}</div>
      </div>
    </div>
    <!-- Investment Details Modal -->
    <div v-if="showInvestmentDetailsModal && selectedInvestment" class="fixed inset-0 z-50 bg-black bg-opacity-70 flex justify-center items-center p-4">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl relative mx-2 modal-scrollable">
        <div class="p-4 bg-green-50 border-b flex justify-between items-center sticky top-0 z-10"> <h3 class="font-bold text-lg text-green-800">{{ selectedInvestment.projectTitle }}</h3> <button class="text-gray-400 hover:text-red-500" @click="showInvestmentDetailsModal=false"><i class="fas fa-times"></i></button> </div>
        <div class="p-6"> <div class="flex flex-col md:flex-row gap-6"> <div class="md:w-1/3"> <video :src="ipfsUrl(selectedInvestment.cid)" controls playsinline webkit-playsinline class="rounded w-full h-40 object-cover bg-black mb-3"></video> <div class="mt-3 space-y-2 text-sm"> <div> <div class="text-xs text-gray-500">Farmer Identifier</div> <div class="font-medium flex items-center font-mono text-xs break-all"> <span>{{ selectedInvestment.farmerWallet }}</span> <button @click="showFarmerProfile(selectedInvestment.farmerWallet)" class="ml-2 text-blue-500 hover:text-blue-700 text-xs focus:outline-none" title="View Farmer Info"> <i class="fas fa-info-circle"></i> </button> <button @click="startOrGoToConversation(selectedInvestment.farmerWallet)" v-if="bedrockIsAuthenticated && currentUserIdentifier !== selectedInvestment.investorWallet" class="ml-2 text-green-600 hover:text-green-700 text-xs focus:outline-none" title="Message Farmer"> <i class="fas fa-envelope"></i> </button> </div> </div> <div> <div class="text-xs text-gray-500">Investment Date</div> <div class="font-medium">{{ selectedInvestment.investmentDate }}</div> </div> <div> <div class="text-xs text-gray-500">Amount Invested</div> <div class="font-medium text-green-700 font-mono">{{ (selectedInvestment.amount || 0).toFixed(2) }} SOL</div> </div> <div> <div class="text-xs text-gray-500">Status</div> <span :class="{'px-2 inline-flex text-xs leading-5 font-semibold rounded-full': true, 'bg-blue-100 text-blue-800': selectedInvestment.status === 'active' || selectedInvestment.status === 'partially_funded', 'bg-green-100 text-green-800': selectedInvestment.status === 'harvested' || selectedInvestment.status === 'funded', 'bg-yellow-100 text-yellow-800': selectedInvestment.status === 'growing', 'bg-red-100 text-red-800': selectedInvestment.status === 'cancelled'}"> {{ selectedInvestment.status === 'active' || selectedInvestment.status === 'partially_funded' ? 'Active' : selectedInvestment.status === 'harvested' ? 'Harvested' : (selectedInvestment.status === 'growing' ? 'Growing' : (selectedInvestment.status === 'cancelled' ? 'Cancelled' : selectedInvestment.status)) }} </span> </div> </div> </div> <div class="md:w-2/3"> <div class="mb-4"> <div class="text-sm font-medium mb-1">{{ selectedInvestment.crop }} ({{ selectedInvestment.method }})</div> <p class="text-sm text-gray-700 max-h-24 overflow-y-auto border p-2 rounded bg-gray-50">{{ selectedInvestment.description }}</p> </div> <div class="mb-4"> <div class="text-xs text-gray-500 mb-1">Project Progress</div> <div class="progress-bar"> <div class="progress-fill bg-green-500" :style="{width: (selectedInvestment.progress || 0) + '%'}"></div> </div> <div class="flex justify-between text-xs mt-1"> <span>{{ (selectedInvestment.progress || 0).toFixed(0) }}% Complete</span> <span>Est. {{ selectedInvestment.timeline }} months total</span> </div> </div> <div class="grid grid-cols-2 gap-4 mb-4 text-sm"> <div> <div class="text-xs text-gray-500">Expected Return (Est.)</div> <div class="font-medium text-green-700 font-mono">{{ calculateExpectedReturn(selectedInvestment) }} SOL</div> </div> <div> <div class="text-xs text-gray-500">ROI (Est.)</div> <div class="font-medium text-green-700">{{ (selectedInvestment.roi || 0).toFixed(1) }}%</div> </div> <div> <div class="text-xs text-gray-500">Land Size</div> <div class="font-medium">{{ (selectedInvestment.acres || 0).toFixed(1) }} acres</div> </div> <div> <div class="text-xs text-gray-500">Your Share (from project ROI)</div> <div class="font-medium">{{ (selectedInvestment.investorShare || 0).toFixed(1) }}%</div> </div> </div> <div v-if="selectedInvestmentProject && selectedInvestmentProject.updates && selectedInvestmentProject.updates.length > 0" class="mb-4"> <h4 class="text-sm font-semibold text-gray-700 mb-2">Farmer Updates</h4> <div class="project-updates-list text-xs"> <div v-for="update in selectedInvestmentProject.updates.slice().reverse()" :key="update.id" class="project-update-item"> <span class="font-medium text-gray-500">{{ update.date }}:</span> {{ update.text }} </div> </div> </div> <div v-else-if="selectedInvestmentProject" class="mb-4 text-xs text-gray-500"> No project updates posted by the farmer yet. </div> <div class="bg-gray-100 p-3 rounded mb-4 border"> <div class="text-sm font-medium mb-1">Platform Transaction (Simulated)</div> <div class="flex items-center text-xs"> <span class="font-mono bg-white px-2 py-1 rounded border mr-2 truncate" :title="selectedInvestment.txHash">{{ selectedInvestment.txHash }}</span> <a :href="solanaExplorerUrl(selectedInvestment.txHash)" target="_blank" class="text-blue-600 hover:underline whitespace-nowrap ml-2"> <i class="fas fa-external-link-alt"></i> View (Demo Link) </a> </div> </div> <div v-if="selectedInvestment.status === 'harvested'" class="bg-green-100 p-3 rounded border border-green-200"> <div class="flex items-center"> <i class="fas fa-check-circle text-green-600 mr-2 text-lg"></i> <div> <div class="font-medium">Harvest Completed & Payout Processed (Sim.)</div> <div class="text-sm">Your simulated return of {{ calculateExpectedReturn(selectedInvestment) }} SOL was processed.</div> </div> </div> </div> <div v-else-if="selectedInvestment.status === 'growing' || selectedInvestment.status === 'partially_funded' || selectedInvestment.status === 'funded'" class="bg-yellow-50 p-3 rounded border border-yellow-200"> <div class="flex items-center"> <i class="fas fa-hourglass-half text-yellow-600 mr-2 text-lg"></i> <div> <div class="font-medium">Project Ongoing</div> <div class="text-sm">{{ selectedInvestment.status === 'funded' ? 'Fully funded.' : selectedInvestment.status === 'partially_funded' ? 'Partial funding.' : '' }} Harvest expected within {{ selectedInvestment.timeline }} months from start. Progress: {{(selectedInvestment.progress || 0).toFixed(0)}}%.</div> </div> </div> </div> <div v-else-if="selectedInvestment.status === 'cancelled'" class="bg-red-50 p-3 rounded border border-red-200"> <div class="flex items-center"> <i class="fas fa-times-circle text-red-600 mr-2 text-lg"></i> <div> <div class="font-medium">Project Cancelled</div> <div class="text-sm">This project funding request was cancelled by the farmer.</div> </div> </div> </div> </div> </div> </div>
        <div class="bg-gray-50 p-4 flex justify-end rounded-b-lg sticky bottom-0 border-t"> <button @click="showInvestmentDetailsModal=false" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded text-sm"> Close </button> </div>
      </div>
    </div>
    <!-- Farmer Profile Modal -->
    <div v-if="showFarmerProfileModal && selectedFarmerProfile" class="fixed inset-0 z-50 bg-black bg-opacity-70 flex justify-center items-center p-4">
      <div class="bg-white rounded-lg shadow-xl w-full max-w-lg relative mx-2 modal-scrollable">
        <div class="p-4 bg-green-50 border-b flex justify-between items-center sticky top-0 z-10"> <h3 class="font-bold text-lg text-green-800 flex items-center"> <i class="fas fa-user-tie mr-2"></i> Farmer Profile </h3> <button class="text-gray-400 hover:text-red-500" @click="closeFarmerProfileModal"><i class="fas fa-times"></i></button> </div>
        <div class="p-6 space-y-5"> <div class="flex items-center space-x-4"> <div class="bg-green-100 rounded-full w-16 h-16 flex items-center justify-center text-green-600 text-2xl"> <i class="fas fa-tractor"></i> </div> <div> <p class="text-xs text-gray-500">Farmer Identifier</p> <p class="font-semibold text-lg text-green-700 font-mono break-all">{{ getFarmerDisplayIdentifier(selectedFarmerProfile.walletAddress, 10) }}</p> <p class="text-sm text-gray-600">PestiVid Name: {{ selectedFarmerProfile.name || 'N/A' }}</p> </div> </div> <div class="border-t pt-4"> <p class="text-xs text-gray-500">Short Bio (Simulated)</p> <p class="text-sm text-gray-700 italic">{{ selectedFarmerProfile.bio || 'This farmer has not provided a bio yet.' }}</p> </div> <div class="grid grid-cols-1 md:grid-cols-2 gap-4 border-t pt-4"> <div> <p class="text-xs text-gray-500">PestiVid Email</p> <p class="text-sm">{{ selectedFarmerProfile.email }}</p> </div> <div> <p class="text-xs text-gray-500">PestiVid Member Since</p> <p class="text-sm">{{ selectedFarmerProfile.memberSince }}</p> </div> </div> <div class="border-t pt-4"> <p class="text-sm font-medium text-gray-700 mb-2">Platform Activity (Simulated):</p> <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm"> <div class="bg-gray-100 p-3 rounded-md"> <p class="font-semibold">{{ selectedFarmerProfile.fundingRequestCount }}</p> <p class="text-xs text-gray-500">Active Funding Request(s)</p> </div> <div class="bg-gray-100 p-3 rounded-md"> <p class="font-semibold">{{ selectedFarmerProfile.activeListingCount }}</p> <p class="text-xs text-gray-500">Active Marketplace Listing(s)</p> </div> </div> <p class="text-xs text-gray-400 mt-2">(Note: Activity counts are based on current items visible on the platform.)</p> </div> </div>
        <div class="bg-gray-50 p-4 flex justify-between items-center rounded-b-lg sticky bottom-0 border-t"> <button @click="messageFarmerFromProfile(selectedFarmerProfile.walletAddress)" v-if="bedrockIsAuthenticated && selectedFarmerProfile && currentUserIdentifier !== selectedFarmerProfile.walletAddress" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm"> <i class="fas fa-paper-plane mr-1"></i> Send Message </button> <div v-else class="w-full"></div> <button @click="closeFarmerProfileModal" class="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded text-sm"> Close </button> </div>
      </div>
    </div>


    <!-- Notification Toast Container -->
    <div class="notification-toast-container">
        <div v-for="n in recentNotifications" :key="n.id" class="notification-toast" :class="{'show': n.show}" :data-notif-id="n.id"> <span :class="['icon', 'icon-' + n.type]"> <i :class="n.type === 'success' ? 'fas fa-check-circle' : (n.type === 'info' ? 'fas fa-info-circle' : (n.type === 'warning' ? 'fas fa-exclamation-triangle' : 'fas fa-bug'))"></i> </span> <span class="message">{{ n.message }}</span> <button @click="dismissNotification(n.id)" class="close-btn">&times;</button> </div>
    </div>
    <!-- Loading/Transaction Modal -->
    <div v-if="showLoadingModal" class="loading-modal"> <div class="loading-content"> <i class="fas fa-spinner fa-spin"></i> <p class="text-gray-700">{{ loadingMessage }}</p> </div> </div>

    <!-- Hidden container for Bedrock Passport React Bridge Component -->
     <div id="bedrock-bridge-container"></div>

  </main>

  <footer class="bg-white border-t py-6 mt-auto text-center text-sm text-gray-500">
    <span> {{ new Date().getFullYear() }} PestiVid  Blockchain Agricultural Platform (Web3 Demo)</span>
  </footer>
</div>

<script>
    // Ensure React and ReactDOM are available
if (!window.React || !window.ReactDOM) {
    console.error('React or ReactDOM not found. Please ensure CDN scripts are loaded.');
     // Optionally disable parts of the app or show an error message
     // For this demo, we'll proceed but Bedrock features will fail gracefully.
}

// --- Orange ID (Bedrock Passport) Integration ---
// Define React components outside of the Vue instance script
// These components interact directly with the Bedrock Passport React Context/Hooks
const { BedrockPassportProvider, LoginPanel, useBedrockPassport } = window.Bedrock || {};

// Check if Bedrock components/hooks are available
const bedrockIsAvailable = BedrockPassportProvider && LoginPanel && useBedrockPassport;
if (!bedrockIsAvailable) {
    console.error('Bedrock Passport components or hooks not found. Orange ID integration will not work.');
}


// Bedrock Passport Configuration (Replace with your project details)
// !!! REPLACE with your actual deployed URL or localhost if testing locally !!!
// This URL must be whitelisted in your Bedrock Passport tenant settings.
const authCallbackUrl = 'https://sindukuriteja.github.io'; // Example: 'http://localhost:8080' or 'https://your-app.com'
// !!! REPLACE with your assigned tenant ID !!!
const tenantId = 'orange-h0zmx5nf44'; // Example: 'orange-abcdef123'

const bedrockConfig = {
  baseUrl: 'https://api.bedrockpassport.com', // Base API URL  no need to change this. Leave as is.
  authCallbackUrl: authCallbackUrl,
  tenantId: tenantId,
};

// React component to sync Bedrock state with Vue
// This component is mounted once globally within the BedrockPassportProvider
const BedrockStateBridge = ({ vueApp }) => {
  // Ensure useBedrockPassport is available
  if (!bedrockIsAvailable) {
       console.error("useBedrockPassport hook not available in BedrockStateBridge.");
       return null;
   }
  const { isAuthenticated, user, isLoading, error, logout } = useBedrockPassport();

   // Expose logout via a method property on the component instance using useImperativeHandle
   // This method will be called by Vue via the ref set on this component instance in Vue's mounted
   React.useImperativeHandle(vueApp.$refs.bedrockBridge, () => ({
     logout: () => {
        // Call the actual Bedrock Passport SDK logout function
        if (typeof logout === 'function') {
            logout();
        } else {
            console.warn("Bedrock Passport logout function not available.");
        }
     }
   }));

  // Call Vue method whenever auth state or user changes
  // Use React.useEffect to avoid unnecessary calls and handle dependencies
  React.useEffect(() => {
      // Check if vueApp and its syncBedrockState method exist before calling
      if (vueApp && typeof vueApp.syncBedrockState === 'function') {
          vueApp.syncBedrockState(isAuthenticated, user, isLoading, error);
      } else {
          console.warn("Vue app instance or syncBedrockState method not available in BedrockStateBridge.");
      }
  }, [isAuthenticated, user, isLoading, error, vueApp]); // Add vueApp as a dependency

  // This component renders nothing visible, it just hooks into context
  return null;
};

// React component to process the auth callback URL
// This component is rendered temporarily on the loginChoice page if callback params are present
const AuthCallbackProcessor = ({ vueApp }) => {
   // Ensure useBedrockPassport is available
   if (!bedrockIsAvailable) {
        console.error("useBedrockPassport hook not available in AuthCallbackProcessor.");
         // Render an error state or message
        return React.createElement(
            'div',
            { style: { textAlign: 'center', padding: '1rem', color: 'red' } },
            'Authentication widget failed to load.'
        );
    }

  const { loginCallback } = useBedrockPassport();
  const [message, setMessage] = React.useState('Processing authentication...');
  const [processingComplete, setProcessingComplete] = React.useState(false);


  React.useEffect(() => {
    async function processLogin() {
      if (!loginCallback) {
          setMessage('Bedrock Passport SDK not fully initialized. Retrying...');
          console.warn("AuthCallbackProcessor: loginCallback not yet available.");
          // Retry processLogin after a short delay
          setTimeout(processLogin, 200); // Retry until loginCallback is available
          return;
      }

      const params = new URLSearchParams(window.location.search);
      const token = params.get('token');
      const refreshToken = params.get('refreshToken');

      if (!token || !refreshToken) {
        setMessage('Authentication callback failed: Tokens missing.');
         if (vueApp && typeof vueApp.addNotification === 'function') {
             vueApp.addNotification('Authentication failed: Tokens missing.', 'error');
             // Redirect to login page if tokens are missing
         } else {
             console.error("Vue app or addNotification not available.");
         }
         setProcessingComplete(true); // Mark as complete to stop spinner
        return;
      }

      try {
        setMessage('Verifying tokens...');
         // Call the actual Bedrock Passport SDK loginCallback function
        const success = await loginCallback(token, refreshToken);

        if (success) {
          setMessage('Login successful! Redirecting...');
          // Remove token parameters from URL *before* calling Vue method
          // history.replaceState is safe as it doesn't trigger a full page reload
          window.history.replaceState({}, document.title, window.location.pathname);
          setProcessingComplete(true); // Mark as complete to stop spinner

          // Call Vue method to handle successful login state and redirection
           if (vueApp && typeof vueApp.handleSuccessfulOrangeIdLogin === 'function') {
             vueApp.handleSuccessfulOrangeIdLogin(success); // Pass the user object from success (though syncBedrockState is primary)
           } else {
              console.error("Vue app or handleSuccessfulOrangeIdLogin not available.");
               // Fallback manual redirect if Vue method fails
               setTimeout(() => { window.location.reload(); }, 1000);
           }
        } else {
          setMessage('Authentication failed. Please try again.');
           if (vueApp && typeof vueApp.addNotification === 'function') {
             vueApp.addNotification('Authentication failed. Please try again.', 'error');
           } else {
               console.error("Vue app or addNotification not available.");
           }
           setProcessingComplete(true); // Mark as complete
        }
      } catch (error) {
        console.error('Login error:', error);
        setMessage('An error occurred during login.');
         if (vueApp && typeof vueApp.addNotification === 'function') {
            vueApp.addNotification('An error occurred during login: ' + (error.message || 'Unknown error'), 'error');
         } else {
             console.error("Vue app or addNotification not available.");
         }
         setProcessingComplete(true); // Mark as complete
      }
    }

    // Start the processing function when the component mounts
    processLogin();

  }, [loginCallback, vueApp]); // Add loginCallback and vueApp as dependencies

  // Render loading indicator or message while processing
  return React.createElement(
    'div',
    { style: { textAlign: 'center', padding: '1rem', minHeight: '200px', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center' } },
    // Show spinner only while processing
    !processingComplete && React.createElement('i', { className: 'fas fa-spinner fa-spin text-3xl text-green-600 mb-4' }),
    React.createElement('p', { className: 'text-gray-700' }, message)
  );
};

// React component to render the Login Panel
// This component is rendered on the loginChoice page when NOT handling a callback
const PestiVidLoginPanelWrapper = () => {
    // Ensure LoginPanel is available
    if (!bedrockIsAvailable) {
         console.error("LoginPanel component not available.");
          return React.createElement(
             'div',
             { style: { textAlign: 'center', padding: '1rem', color: 'red' } },
             'Authentication widget failed to load. Please check your internet connection.'
         );
     }
   // No need to use useBedrockPassport hook here, LoginPanel component handles authentication internally
   // It relies on the BedrockPassportProvider context being available from a parent component (the global one).
   return React.createElement(LoginPanel, {
       // Content options
       title: "Sign in to",
       logo: "https://irp.cdn-website.com/e81c109a/dms3rep/multi/orange-web3-logo-v2a-20241018.svg", // Orange ID Logo
       logoAlt: "Orange Web3",
       // PestiVid branding elements can be styled via CSS
       // Remove WalletConnect button as PestiVid uses its own flow/simulated Solana
       walletButtonText: "Connect Wallet", // This text won't be used if showConnectWallet is false
       showConnectWallet: false, // Keep WalletConnect disabled
       separatorText: "OR",

       // Feature toggles - Enable/Disable according to your needs
       features: {
           enableWalletConnect: false, // Explicitly disable if not using actual WalletConnect
           enableAppleLogin: true,
           enableGoogleLogin: true,
           enableEmailLogin: true, // Recommended to enable email/password login
       },

       // Style options - Using PestiVid/Tailwind classes where appropriate
       titleClass: "text-xl font-bold text-green-800",
       logoClass: "h-8 mx-auto mb-4", // Center logo
       panelClass: "p-4 md:p-6 rounded-lg max-w-[450px] mx-auto", // Match Vue wrapper padding/sizing
       buttonClass: "hover:border-green-500 focus:ring-green-500", // Match PestiVid button colors
       separatorTextClass: "bg-white text-gray-500", // Use white background for separator text
       separatorClass: "bg-gray-300", // Use gray for separator line
       linkRowClass: "justify-center", // Center social login links
       headerClass: "justify-center flex-col", // Center title and logo vertically
       // You can add more style overrides based on Bedrock Passport documentation
   });
};


// Vue App Instance
const app = new Vue({
    el: "#app",
    data: {
      current: 'landing',
      showMobileMenu: false,

      // --- Authentication State (Now synced from Bedrock Passport) ---
      currentUserIdentifier: null, // Bedrock User ID (string like 'bp_...')
      bedrockIsAuthenticated: false, // State from Bedrock SDK (boolean)
      bedrockUser: null, // User object from Bedrock SDK ({ id: 'bp_...', bedrockId: '...', email: '...', name: '...' ...})
      bedrockIsLoading: true, // Loading state from Bedrock SDK (boolean)
      bedrockError: null, // Error state from Bedrock SDK (Error object or null)
      isAuthProcessing: true, // Combined flag for UI state during Bedrock processes + PestiVid profile loading

      // Unified PestiVid User Profile Data (loaded or set during onboarding)
      role: '', // PestiVid specific role ('farmer', 'buyer', 'investor')
      userName: '', // PestiVid specific name (can be different from Bedrock name)
      userEmail: '', // PestiVid specific email (can be different from Bedrock email)
      userPhone: '',
      memberSince: '',
      farmerLocationCity: '',

      // Onboarding State
      selectedRoleOnboarding: '',
      userNameOnboarding: '',
      userEmailOnboarding: '',
      userPhoneOnboarding: '',
      farmerLocationCityOnboarding: '',

      // --- PestiVid App Data (Simulated Backend/Blockchain via localStorage) ---
      // Global data arrays (all users' data, loaded and filtered)
      allFarmerVideos: [], // All uploaded videos by any farmer
      allListings: [], // All active crop listings
      allFundingRequests: [], // All funding requests
      allBuyerPurchases: [], // All completed buyer purchases
      allInvestorInvestments: [], // All completed investor investments
      allInvestorTransactions: [], // All platform transactions
      allConversations: [], // All chat conversations
      allMessages: [], // All chat messages
      allUserProfiles: {}, // Map of userIdentifier -> {role, name, email, phone, memberSince, farmerLocationCity}

      // Filtered data for the current user (populated by filterDataForCurrentUser)
      farmerVideos: [],
      farmerListings: [],
      farmerFundingRequests: [],
      buyerPurchases: [],
      investorInvestments: [],
      investorTransactions: [],
      conversations: [], // Conversations for the current user
      messages: [], // Messages for the active conversation


      // PestiVid Feature State
      recordForm: {crop:'', pesticide:'', location:'', pesticideCompany: '', purpose: 'agristream'},
      recordStream: null, recordMediaRecorder: null, recording: false, recordBlob: null, recordBlobUrl: '',
      showLive: false, uploadCid: '', uploading: false, uploadError: '', lastUploadedVideoPurpose: '',

      listingForm: {cid:'', minPrice: null, maxPrice: null, notifyBuyers: true}, // Use null for numbers initially
      createdListingId: null, listingNotificationSent: false,

      fundingForm: { title: '', crop: '', acres: null, amount: null, method: '', cid: '', description: '', timeline: null, roi: null, investorShare: null, notifyInvestors: true },
      createdFundingRequest: false,
      newUpdateText: {}, // For adding farmer updates (not implemented in UI yet, but structure exists)


      selectedPurchase: null, showPurchaseVideo: false, // For viewing purchase video modal

      showBuyModal: false,
      selectedListing: null, purchaseAmount: null, purchaseStatus: '', purchaseError: '',

      investmentAmounts: {}, investmentErrors: {}, // For tracking investment input per project
      showInvestmentDetailsModal: false, selectedInvestment: null, selectedInvestmentProject: null, // For viewing investment details modal

      showFarmerProfileModal: false, selectedFarmerProfile: null, // For viewing farmer profile modal

      // !!! REPLACE 'YOUR_PINATA_JWT' with your actual Pinata JWT. Video uploads WILL FAIL without it. !!!
      pinataJwt: 'YOUR_PINATA_JWT',
      // !!! REPLACE 'YOUR_PINATA_GATEWAY_HOSTNAME' (e.g., 'your-gateway-name.mypinata.cloud' or 'gateway.pinata.cloud'). Video playback WILL FAIL without it. !!!
      pinataGateway: 'YOUR_PINATA_GATEWAY_HOSTNAME', // e.g., 'gateway.pinata.cloud' or your dedicated gateway hostname

      // !!! REPLACE 'YOUR_OPENWEATHERMAP_API_KEY'. Weather feature WILL NOT WORK without it. !!!
      weatherApiKey: 'YOUR_OPENWEATHERMAP_API_KEY',
      currentWeather: null, forecastWeather: [], weatherLoading: false, weatherError: '',
      buyerFilters: {crop:'', location:'', pesticideCompany: ''},
      investorFilters: {crop: '', method: '', minRoi: null, maxAmount: null},

      // !!! REPLACE 'YOUR_GEMINI_API_KEY_HERE'. Plant recommendation WILL FAIL without it. !!!
      // Client-side API keys are insecure for production. Use a backend proxy.
      geminiApiKey: 'YOUR_GEMINI_API_KEY_HERE',
      plantImageFile: null,
      plantImageUrl: null,
      plantImageMimeType: null,
      analysisInProgress: false,
      analysisResultText: '',
      parsedAnalysis: { plantName: null, diseaseName: null, treatmentRecommended: null },
      analysisErrorText: '',


      activeConversationId: null, messageInputText: '',
      notifications: [], // Queue of notifications to show
      recentNotifications: [], // Notifications currently displayed as toasts
      notificationTimeout: 6000, // Duration for toasts (milliseconds)

      showLoadingModal: false, loadingMessage: '',
      targetAgriStreamVideoCid: null, highlightedAgriStreamVideoCid: null,

      // React root references for cleanup
      bedrockReactRoot: null, // Root for the loginChoice page widget
      bedrockBridgeRoot: null, // Root for the global state bridge
    },
    computed: {
      // isUserAuthenticated is now derived from bedrockIsAuthenticated and role
      isUserAuthenticated() {
          // User is considered "authenticated to PestiVid" if Bedrock Passport says they are logged in AND
          // they have a PestiVid profile (meaning currentUserIdentifier is set and matches a profile with a role).
          // For simplicity in this demo, bedrockIsAuthenticated is sufficient for the header/login gate.
          // Access to specific portals relies on the `role` being set.
          return !!this.bedrockIsAuthenticated && !!this.role && !!this.currentUserIdentifier;
      },
      displayedUserIdentifier() {
          if (!this.currentUserIdentifier) return '';
          if (this.userName && this.userName.trim()) return this.userName.split(' ')[0]; // Use PestiVid name first if set

          // Fallback to Bedrock ID properties if user object exists
          if (this.bedrockUser && this.bedrockUser.id === this.currentUserIdentifier) {
               if (this.bedrockUser.bedrockId && this.bedrockUser.bedrockId !== 'N/A') { // Use bedrockId if available
                    const id = String(this.bedrockUser.bedrockId);
                    if (id.length > 12) return `${id.substring(0, 6)}...${id.substring(id.length - 4)}`;
                    return id;
               }
               if (this.bedrockUser.name && this.bedrockUser.name.trim()) return this.bedrockUser.name.split(' ')[0]; // Use Bedrock name if available
               if (this.bedrockUser.email && this.bedrockUser.email.trim()) return this.bedrockUser.email; // Use Bedrock email if available
          }

          // Fallback to truncated currentUserIdentifier (should be the bedrockUser.id)
          const id = String(this.currentUserIdentifier);
          if (id.length > 12) return `${id.substring(0, 6)}...${id.substring(id.length - 4)}`;
          return id;
      },
      uniqueCrops() {
         // Get unique crop types from all active listings for the buyer filter
         if (!this.allListings) return [];
         const crops = this.allListings.map(l => l.crop).filter(Boolean);
         return [...new Set(crops)].sort();
      },
      filteredListings() {
          // Filter active listings based on buyer filter criteria
          if (!this.allListings) return [];
          const oneDayAgo = Date.now() - (24*60*60*1000); // Define 'new' as within the last 24 hours
          return this.allListings
              .filter(l => l.status === 'active') // Only show active listings
              .map(l => ({...l, isNew: new Date(l.createdAt).getTime() > oneDayAgo })) // Add isNew flag
              .filter(l => {
                  const cropMatch = !this.buyerFilters.crop || (l.crop || '').toLowerCase() === this.buyerFilters.crop.toLowerCase();
                  const locMatch = !this.buyerFilters.location || (l.location || '').toLowerCase().includes(this.buyerFilters.location.toLowerCase());
                  const companyMatch = !this.buyerFilters.pesticideCompany || (l.pesticideCompany || '').toLowerCase().includes(this.buyerFilters.pesticideCompany.toLowerCase());
                  return cropMatch && locMatch && companyMatch;
              });
      },
      availableVideosForListing() {
          // Videos the current farmer can use to create a new listing (unlisted and not used for funding)
           if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.farmerVideos) return [];
          const listedCids = new Set(this.allListings.filter(l => l.farmerWallet === this.currentUserIdentifier).map(l => l.cid)); // Check *all* listings by this farmer
          const fundingCids = new Set(this.allFundingRequests.filter(r => r.farmerWallet === this.currentUserIdentifier).map(r => r.cid)); // Check *all* funding requests by this farmer
          return this.allFarmerVideos.filter(v =>
              v.farmerWallet === this.currentUserIdentifier &&
              (v.purpose === 'sell' || v.purpose === 'agristream') && // Only 'sell' or 'agristream' can be listed
              !listedCids.has(v.cid) &&
               !fundingCids.has(v.cid) // Don't list videos used for funding requests
          );
      },
      availableVideosForFunding() {
          // Videos the current farmer can use for a new funding request (unlisted and not used for listing)
           if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.farmerVideos) return [];
           const fundingCids = new Set(this.allFundingRequests.filter(r => r.farmerWallet === this.currentUserIdentifier).map(r => r.cid)); // Check *all* funding requests by this farmer
           const listedCids = new Set(this.allListings.filter(l => l.farmerWallet === this.currentUserIdentifier).map(l => l.cid)); // Check *all* listings by this farmer
           return this.allFarmerVideos.filter(v =>
               v.farmerWallet === this.currentUserIdentifier &&
               (v.purpose === 'funding' || v.purpose === 'agristream') && // Only 'funding' or 'agristream' can be used for funding
               !fundingCids.has(v.cid) &&
               !listedCids.has(v.cid) // Don't use videos already listed for sale
           );
      },
      uniqueFundingCrops() {
          // Get unique crop types from all active funding requests for the investor filter
           if (!this.allFundingRequests) return [];
           const crops = this.allFundingRequests.map(r => r.crop).filter(Boolean);
           return [...new Set(crops)].sort();
      },
      filteredFundingRequests() {
          // Filter funding requests based on investor filter criteria and status
           if (!this.allFundingRequests) return [];
           const oneDayAgo = Date.now() - (24*60*60*1000); // Define 'new' as within the last 24 hours
           return this.allFundingRequests
               .filter(r => r.status === 'pending' || r.status === 'partially_funded') // Only show requests still seeking funding
               .map(r => ({ ...r, isNew: new Date(r.createdAt).getTime() > oneDayAgo })) // Add isNew flag
               .filter(r => {
                   const cropMatch = !this.investorFilters.crop || (r.crop||'').toLowerCase() === this.investorFilters.crop.toLowerCase();
                   const methodMatch = !this.investorFilters.method || (r.method||'').toLowerCase() === this.investorFilters.method.toLowerCase();
                   const roiMatch = (this.investorFilters.minRoi === null || this.investorFilters.minRoi === '') || (r.roi >= this.investorFilters.minRoi);
                   const amountMatch = (this.investorFilters.maxAmount === null || this.investorFilters.maxAmount === '') || (r.amount <= this.investorFilters.maxAmount);
                   return cropMatch && methodMatch && roiMatch && amountMatch;
               });
      },
      totalInvestedAmount() {
          // Calculate total amount invested by the current user
          if (!this.investorInvestments || this.investorInvestments.length === 0) return '0.00';
          const total = this.investorInvestments.reduce((sum, inv) => sum + (inv.amount || 0), 0);
          return total.toFixed(2);
      },
      investorActiveProjects() {
          // Count active/growing/partially funded investments for the current user
          if (!this.investorInvestments) return 0;
          return this.investorInvestments.filter(inv => inv.status === 'active' || inv.status === 'growing' || inv.status === 'partially_funded' || inv.status === 'funded').length;
      },
      investorCompletedProjects() {
          // Count harvested/completed investments for the current user
          if (!this.investorInvestments) return 0;
          return this.investorInvestments.filter(inv => inv.status === 'harvested').length;
      },
      investorAvgRoi() {
          // Calculate simple average ROI across all investments for the overview
          if (!this.investorInvestments || this.investorInvestments.length === 0) return '0.0';
          // Filter for investments where ROI is a valid number > 0 to avoid skewing average with 0 or null
          const validInvestments = this.investorInvestments.filter(inv => typeof inv.roi === 'number' && inv.roi > 0);
          if (validInvestments.length === 0) return '0.0'; // Avoid division by zero

          const totalRoi = validInvestments.reduce((sum, inv) => sum + inv.roi, 0);
           return (totalRoi / validInvestments.length).toFixed(1);
      },
      userConversations() {
          // Filter conversations for the current user and sort by last message timestamp
           if (!this.bedrockIsAuthenticated || !this.allConversations || !this.currentUserIdentifier) return [];
          return this.allConversations
              .filter(conv => conv.participants.includes(this.currentUserIdentifier))
              .sort((a, b) => new Date(b.lastMessageTimestamp).getTime() - new Date(a.lastMessageTimestamp).getTime())
               .map(conv => {
                   // Augment conversation with last message snippet and unread count
                   const convoMessages = this.allMessages.filter(msg => msg.conversationId === conv.id);
                   const lastMsg = convoMessages.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())[0];
                   const unreadCount = convoMessages.filter(msg => msg.receiver === this.currentUserIdentifier && !msg.read).length;
                   return {
                       ...conv,
                       lastMessageSnippet: lastMsg ? (lastMsg.text.length > 50 ? lastMsg.text.substring(0, 47) + '...' : lastMsg.text) : 'No messages yet.',
                       lastMessageTimestamp: lastMsg ? lastMsg.timestamp : conv.createdAt, // Use created date if no messages
                       unreadCount: unreadCount
                   };
               });
      },
      currentMessages() {
          // Filter messages for the active conversation, sorted by timestamp
          if (!this.activeConversationId || !this.bedrockIsAuthenticated || !this.allMessages || !this.currentUserIdentifier) return [];
          return this.allMessages.filter(msg => msg.conversationId === this.activeConversationId).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
      },
      activeConversationPartnerIdentifier() {
          // Get the identifier of the other participant in the active conversation
          if (!this.activeConversationId || !this.bedrockIsAuthenticated || !this.allConversations || !this.currentUserIdentifier) return null;
          const conv = this.allConversations.find(c => c.id === this.activeConversationId);
          if (!conv) return null;
          return conv.participants.find(p => p !== this.currentUserIdentifier);
      },
      activeConversationPartnerDisplayAddress() {
          // Get the display name for the other participant
          const partnerId = this.activeConversationPartnerIdentifier;
          if (!partnerId) return '?';
           return this.getDisplayIdentifier(partnerId); // Use the general helper
      },
       activeConversationPartnerInitial() {
           // Get the first initial of the other participant's display name
           const partnerDisplay = this.activeConversationPartnerDisplayAddress;
           if (!partnerDisplay || partnerDisplay === '?' || partnerDisplay === 'N/A') return '?';
            // Handle truncated names correctly
            if (partnerDisplay.includes('...')) {
                const partnerId = this.activeConversationPartnerIdentifier; // Get the actual ID
                const profile = this.allUserProfiles[partnerId];
                if (profile && profile.name && profile.name.trim()) return profile.name.charAt(0).toUpperCase();
                // Fallback to identifier initial if no name available for truncated ID
                if (partnerId) return partnerId.charAt(0).toUpperCase();
                 return '?';
            }
           return partnerDisplay.charAt(0).toUpperCase();
       },
      unreadMessageCount() {
          // Total unread messages for the current user across all conversations
          if (!this.bedrockIsAuthenticated || !this.allMessages || !this.currentUserIdentifier) return 0;
          return this.allMessages.filter(msg => msg.receiver === this.currentUserIdentifier && !msg.read).length;
      },
    },
    watch: {
      current(newPage, oldPage) {
          console.log(`Switching page from "${oldPage}" to "${newPage}"`);
          window.scrollTo(0,0); // Scroll to top on page change

           // Handle rendering/unmounting the Bedrock React widget on the loginChoice page
          if (newPage === 'loginChoice') {
              this.$nextTick(() => {
                   // Delay slightly to ensure DOM is ready after transition if needed
                  setTimeout(() => { this.renderBedrockLoginWidget(); }, 50);
              });
          } else if (oldPage === 'loginChoice') {
               // Unmount the React widget when leaving the login page
               this.unmountBedrockLoginWidget();
          }


          // Highlight AgriStream video if navigating there with a target CID
          if (newPage === 'farmerAgriStream' && this.targetAgriStreamVideoCid) {
              // Use a timeout to ensure the DOM has updated with the video list
              this.$nextTick(() => {
                  setTimeout(() => { // Add a small delay for rendering
                      if (this.farmerVideos.some(v => v.cid === this.targetAgriStreamVideoCid)) {
                          this.scrollToAndHighlightAgriStreamVideo();
                      } else {
                          // If target video isn't immediately available, maybe it's loading? Or just clear it.
                          console.warn(`Target AgriStream video CID ${this.targetAgriStreamVideoCid} not found in farmerVideos.`);
                          this.targetAgriStreamVideoCid = null; // Clear if not found
                      }
                  }, 100); // Delay
              });
          } else if (oldPage === 'farmerAgriStream') {
              // Clear highlight when leaving AgriStream
              this.highlightedAgriStreamVideoCid = null;
              this.targetAgriStreamVideoCid = null; // Clear target CID as well
          }

          // Clear Plant Recommend state if leaving the page
          if (oldPage === 'plantRecomendation' && newPage !== 'plantRecomendation') {
              this.plantImageFile = null;
              if (this.plantImageUrl) URL.revokeObjectURL(this.plantImageUrl); // Clean up previous URL
              this.plantImageUrl = null;
              this.plantImageMimeType = null;
              this.analysisResultText = '';
              this.parsedAnalysis = { plantName: null, diseaseName: null, treatmentRecommended: null };
              this.analysisErrorText = '';
          }

          // Ensure logged-in users are on a role-appropriate page or onboarding
          // This logic now primarily depends on bedrockIsAuthenticated and whether a PestiVid role is set
          // Also prevent redirection loops during Bedrock loading
          if (this.bedrockIsAuthenticated && !this.isAuthProcessing) { // Use isAuthProcessing here
               const nonPortalPages = ['landing', 'loginChoice', 'roleSelection'];
               if (!this.role && newPage !== 'roleSelection') {
                  // If user is Bedrock authenticated but has no PestiVid role, force to role selection (unless on landing)
                   if (newPage !== 'landing') { // Don't force redirect from landing immediately on load
                      console.log(`[Watcher:current] User Bedrock authenticated (No PestiVid Role), on ${newPage}. Redirecting to roleSelection.`);
                      this.switchPage('roleSelection');
                   }
               } else if (this.role && nonPortalPages.includes(newPage)) {
                   // If user is Bedrock authenticated and has a PestiVid role, prevent staying on login/onboarding/landing
                    console.log(`[Watcher:current] User Bedrock authenticated (PestiVid Role: ${this.role}), on ${newPage}. Redirecting via getStarted().`);
                    this.getStarted(); // getStarted will route to the correct portal page
               } else if (newPage === 'messaging' && this.activeConversationId) {
                    this.$nextTick(() => { // Ensure message container exists
                         this.scrollToMessageBottom(); // Scroll to bottom if opening messaging with an active chat
                         this.markConversationAsRead(this.activeConversationId); // Mark as read when viewing
                    });
               } else if (newPage === 'investorPortfolio' && this.role === 'investor') {
                   this.$nextTick(() => { // Ensure elements exist
                     this.updateInvestmentProgress(); // Update progress when viewing portfolio
                   });
               } else if (newPage === 'userProfile' && this.role === 'farmer' && this.farmerLocationCity && !this.currentWeather && !this.weatherLoading && (this.weatherApiKey !== 'YOUR_OPENWEATHERMAP_API_KEY' && !this.weatherApiKey.includes('YOUR_'))) {
                    // Fetch weather if on profile page as farmer, city is set, and weather hasn't been fetched (and API key is set)
                    this.fetchWeather();
               }
           } else if (!this.bedrockIsAuthenticated && !this.isAuthProcessing) {
                // If not authenticated and loading is complete, ensure we are on landing or login
                const allowedPages = ['landing', 'loginChoice'];
                if (!allowedPages.includes(newPage)) {
                    console.log(`[Watcher:current] User not authenticated, on ${newPage}. Redirecting to landing.`);
                     this.switchPage('landing'); // Redirect to landing
                }
           }
      },
      // Watch for changes in Bedrock Passport state (delegated from the React Bridge)
       bedrockIsAuthenticated(newVal, oldVal) {
            console.log(`[Watcher:bedrockIsAuthenticated] changed from ${oldVal} to ${newVal}`);
             // Add notification on state change, but only when it becomes true
            if (newVal === true && oldVal === false && this.currentUserIdentifier) {
                 this.addNotification(`Authentication successful! Welcome ${this.userName ? this.userName.split(' ')[0] : this.getDisplayIdentifier(this.currentUserIdentifier, 10)}.`, "success");
            }
            // If Bedrock state changes, the syncBedrockState method handles the rest (currentUserIdentifier, profile load, filtering, redirect)
       },
       bedrockIsLoading(newVal, oldVal) {
            console.log(`[Watcher:bedrockIsLoading] changed from ${oldVal} to ${newVal}`);
            // Update combined processing flag
            this.isAuthProcessing = newVal; // Simple sync for this demo
       },
       isAuthProcessing(newVal, oldVal) {
            console.log(`[Watcher:isAuthProcessing] changed from ${oldVal} to ${newVal}`);
             // Control loading modal based on combined state
             // Show modal if we are processing AND not already authenticated
             if (newVal && !this.bedrockIsAuthenticated) {
                 this.showLoadingModal = true;
                 this.loadingMessage = "Processing authentication..."; // Default message
             } else if (!newVal) {
                 // Finished processing
                 this.showLoadingModal = false;
                 this.loadingMessage = '';
                 // After loading finishes, if authenticated and no role, force to role selection
                 if(this.bedrockIsAuthenticated && !this.role && this.current !== 'roleSelection' && this.current !== 'landing') {
                     console.log("[Watcher:isAuthProcessing] Loading finished, authenticated, no role. Redirecting to roleSelection.");
                     this.switchPage('roleSelection');
                     this.addNotification("Your PestiVid profile needs completion. Please select your role.", "warning");
                 } else if (this.bedrockIsAuthenticated && this.role && (this.current === 'loginChoice' || this.current === 'roleSelection')) {
                     // If authenticated with a role and still on login/onboarding, redirect to portal
                      console.log(`[Watcher:isAuthProcessing] Loading finished, authenticated with role. On ${this.current}. Redirecting via getStarted.`);
                      this.getStarted();
                 } else if (!this.bedrockIsAuthenticated && this.current !== 'loginChoice' && this.current !== 'landing') {
                      // If loading finished and not authenticated, redirect to landing
                      console.log("[Watcher:isAuthProcessing] Loading finished, not authenticated. Redirecting to landing.");
                      this.switchPage('landing');
                 }
             }
       },
       bedrockError(newVal, oldVal) {
           if (newVal) {
               console.error(`[Watcher:bedrockError] Bedrock error:`, newVal);
                // Only show error notification if it's a new, non-null error
               if (newVal !== oldVal) {
                 this.addNotification(`Authentication error: ${newVal.message || 'Unknown error'}`, 'error');
               }
           }
       },

       // Watch for changes in the filtered messages array for the active conversation
       currentMessages: {
           handler(newVal, oldVal) {
              // Scroll to bottom when messages update in active conversation, but only if user is already viewing the chat
               // Check if messageContainer exists (i.e., user is on the messaging page)
               if (this.current === 'messaging' && this.activeConversationId && this.$refs.messageContainer) {
                  // Only scroll if the last message was sent by the current user OR
                  // if the container is already scrolled near the bottom.
                  // This prevents automatic scrolling when new messages arrive while the user is reading older ones.
                   this.$nextTick(() => {
                       const container = this.$refs.messageContainer;
                        if (container) {
                           const isScrolledToBottom = container.scrollHeight - container.clientHeight <= container.scrollTop + 50; // 50px tolerance
                            const lastNewMessage = newVal[newVal.length - 1];
                            const wasLastMessageSentByMe = lastNewMessage && lastNewMessage.sender === this.currentUserIdentifier;

                            if (isScrolledToBottom || wasLastMessageSentByMe) {
                                container.scrollTop = container.scrollHeight;
                            }
                       }
                   });
               }
           },
           deep: true // Deep watch is needed for array changes
       },
        notifications: {
          handler() {
              // Auto-show notifications as they are added, up to a limit
              if (this.notifications.length > 0) {
                  this.showNextToastNotification();
              }
          },
          deep: true // Deep watch is needed for array changes
       },
    },
    created() {
        // Before mounting, set up initial data structures if localStorage is empty
        this.loadDataFromLocalStorage(); // Load existing data first
         // Note: User session loading/filtering now happens in mounted after Bedrock initializes
    },
    mounted() {
        console.log("Vue app mounted.");

         // Check if Bedrock is available before attempting React rendering
         if (!bedrockIsAvailable) {
              console.error("Bedrock Passport SDK not available. Skipping React component mounting.");
              this.isAuthProcessing = false; // Ensure loading state is false if SDK is missing
              // Optionally, keep a basic login/signup button for a fallback simulation
              // For this demo, we'll rely on Bedrock being present.
               // Add an error notification
              this.addNotification("Authentication SDK missing. Please check your internet connection or browser compatibility.", "error");
               // Maybe set a flag to disable Bedrock related features?
              this.bedrockIsAvailable = false; // Add this data property? Or just rely on the global constant.
               // Ensure user-specific data is cleared if SDK is missing
               this.clearUserSession(false); // Clear local session data without redirecting immediately

               // If we are on loginChoice or a callback URL but Bedrock isn't available, redirect away
               const params = new URLSearchParams(window.location.search);
               const isCallback = params.has('token') && params.has('refreshToken');
               if (this.current === 'loginChoice' || isCallback) {
                    this.switchPage('landing'); // Go back to landing
               }

              return; // Stop mounted execution related to Bedrock
         }


        // Get container for the global Bedrock State Bridge
        const bridgeContainer = document.getElementById('bedrock-bridge-container');
        if (!bridgeContainer) {
             console.error("Bedrock bridge container element not found! Authentication will not work correctly.");
             this.isAuthProcessing = false;
             this.addNotification("Internal Error: Authentication container not found.", "error");
             return; // Stop mounted execution
        }
         // Create React Root for the global state bridge
        this.bedrockBridgeRoot = ReactDOM.createRoot(bridgeContainer);

         // Render the BedrockPassportProvider and the BedrockStateBridge globally
         // This establishes the context and syncs state regardless of the current page
         this.bedrockBridgeRoot.render(
            React.createElement(
                BedrockPassportProvider,
                bedrockConfig,
                // Pass the Vue app instance to the bridge component and set a ref
                React.createElement(BedrockStateBridge, { vueApp: this, ref: 'bedrockBridge' })
            )
        );
         console.log("Bedrock State Bridge and Provider mounted globally.");

         // Get container for the loginChoice page content
         const loginContainer = document.getElementById('bedrock-react-container');
         if (!loginContainer) {
             console.error("Bedrock login container element not found! Login page will not render.");
             // This might not be a fatal error if the user doesn't visit the login page,
             // but worth logging.
         } else {
              // Create React Root for the login page container, but don't render yet
              this.bedrockReactRoot = ReactDOM.createRoot(loginContainer);
         }


         // Check URL for Bedrock callback parameters on initial load
        const params = new URLSearchParams(window.location.search);
        const isCallback = params.has('token') && params.has('refreshToken');

        if (isCallback) {
             console.log("Callback parameters detected on initial load.");
             // We are in a callback flow. Switch to loginChoice page.
             // The 'current' watcher will then detect the page change and render the AuthCallbackProcessor.
             this.switchPage('loginChoice');
              // Keep the loading modal visible
             this.showLoadingModal = true;
             this.loadingMessage = "Processing authentication callback...";
        } else {
             // Not a callback. If not already authenticated (checked by BedrockStateBridge)
             // and not on landing/loginChoice, getStarted will handle redirection after loading.
              console.log("No callback parameters on initial load. Bedrock State Bridge will handle initial state sync.");
              // The syncBedrockState method (called by the BedrockStateBridge) will update isAuthProcessing
              // and potentially redirect the user after it finishes loading and checks PestiVid profile.
        }


         // Start the notification toaster logic
         this.showNextToastNotification();

          // Start simulating investment progress updates periodically
          this.investmentProgressInterval = setInterval(() => {
             // Only run simulation if Bedrock SDK is available (avoids errors with missing context)
             if (bedrockIsAvailable && this.bedrockIsAuthenticated) { // Only run if a user is logged in via Bedrock
                  this.updateInvestmentProgress();
              }
          }, 60000); // Check/update every minute (adjust as needed)
    },
    beforeDestroy() {
        // Clean up MediaRecorder and stream if active
        this.stopVideo();
         // Clear the progress simulation interval
        if (this.investmentProgressInterval) {
            clearInterval(this.investmentProgressInterval);
        }
         // Revoke any object URLs created for image previews
         if (this.plantImageUrl) {
             URL.revokeObjectURL(this.plantImageUrl);
         }
         // Clean up React roots when Vue app is destroyed
         this.unmountBedrockLoginWidget(); // Unmount login page widget
         if (this.bedrockBridgeRoot) {
            console.log("Unmounting Bedrock State Bridge.");
            this.bedrockBridgeRoot.unmount();
             this.bedrockBridgeRoot = null;
         }
    },
    methods: {
      // --- Global App Methods ---
      switchPage(page) {
        this.current = page;
        this.showMobileMenu = false; // Close mobile menu on navigation
      },
      navigateToPageWithParam(page, paramName, paramValue) {
        // Helper to navigate and pass a parameter (used for pre-selecting video in forms or highlighting)
        console.log(`Navigating to "${page}" with param "${paramName}" = "${paramValue}"`);
        if (page === 'farmerSell' && paramName === 'cid') {
            this.listingForm.cid = paramValue;
        } else if (page === 'farmerFunding' && paramName === 'cid') {
            this.fundingForm.cid = paramValue;
        } else if (page === 'farmerAgriStream' && paramName === 'highlightCid') {
            this.targetAgriStreamVideoCid = paramValue;
        }
        this.switchPage(page);
      },
      getStarted() {
           console.log(`getStarted called. BedrockAuth: ${this.bedrockIsAuthenticated}, Role: ${this.role}, Current: ${this.current}, isAuthProcessing: ${this.isAuthProcessing}`);
           // Prevent immediate navigation if auth is still loading/processing
           if (this.isAuthProcessing) {
               console.log("getStarted: Auth is processing, delaying navigation.");
               // The syncBedrockState / isAuthProcessing watcher will handle redirection once loading is complete.
               return; // Exit, wait for state change
           }

          if (!this.bedrockIsAuthenticated) {
              console.log("getStarted: Not authenticated via Bedrock, navigating to loginChoice.");
              this.switchPage('loginChoice');
          } else if (!this.role) {
              console.log("getStarted: Bedrock Authenticated, no PestiVid role, navigating to roleSelection.");
              this.switchPage('roleSelection');
          } else {
              console.log(`getStarted: Bedrock Authenticated with PestiVid role ${this.role}. Navigating to specific portal page.`);
              // Navigate to the appropriate starting page based on role
              if (this.role === 'farmer') {
                  this.switchPage('farmerPestiVid');
              } else if (this.role === 'buyer') {
                  this.switchPage('buyerAgriSell');
              } else if (this.role === 'investor') {
                  this.switchPage('investorProjects');
              } else {
                  console.warn(`getStarted: Unknown PestiVid role "${this.role}". Defaulting to landing.`);
                  this.switchPage('landing'); // Fallback
              }
          }
      },
      completeOnboarding() {
          if (!this.bedrockIsAuthenticated || !this.currentUserIdentifier || !this.selectedRoleOnboarding || !this.userNameOnboarding.trim() || !this.userEmailOnboarding.trim()) {
              this.addNotification("Please fill in all required fields and select a role.", "warning");
              return;
          }
          console.log(`Completing onboarding for user ${this.currentUserIdentifier} with role ${this.selectedRoleOnboarding}`);

          // Create or update the user profile in the simulated backend
          const profile = this.allUserProfiles[this.currentUserIdentifier] || {};
          profile.walletAddress = this.currentUserIdentifier; // Use Bedrock ID as the PestiVid identifier
          profile.bedrockId = this.bedrockUser?.bedrockId || 'N/A'; // Store Bedrock's bedrockId if available
          profile.role = this.selectedRoleOnboarding;
          profile.name = this.userNameOnboarding.trim();
          profile.email = this.userEmailOnboarding.trim();
          profile.phone = this.userPhoneOnboarding.trim();
          profile.memberSince = profile.memberSince || new Date().toLocaleDateString(); // Set once on first profile creation
           if (this.selectedRoleOnboarding === 'farmer') {
               profile.farmerLocationCity = this.farmerLocationCityOnboarding.trim();
           } else {
               delete profile.farmerLocationCity; // Remove if not a farmer
           }

          this.$set(this.allUserProfiles, this.currentUserIdentifier, profile); // Use $set for reactivity

          // Update current user's state in Vue
          this.role = profile.role;
          this.userName = profile.name;
          this.userEmail = profile.email;
          this.userPhone = profile.phone;
          this.memberSince = profile.memberSince;
          this.farmerLocationCity = profile.farmerLocationCity || '';


          this.saveDataToLocalStorage(); // Save the new/updated profile

          // Filter data for the now-defined user role
          this.filterDataForCurrentUser();

          this.addNotification(`Welcome to PestiVid, ${this.userName}! Your role is set to ${this.role}.`, "success");
          console.log(`Onboarding complete for ${this.currentUserIdentifier}. Profile saved.`);

          // Redirect to the appropriate starting page
          this.getStarted(); // Use getStarted to navigate based on the new role
      },


      // --- Orange ID (Bedrock Passport) Handlers ---
      // This method is called by the BedrockStateBridge React component
      syncBedrockState(isAuthenticated, bedrockUser, isLoading, error) {
           console.log(`[Vue] syncBedrockState called: isAuthenticated=${isAuthenticated}, user ID=${bedrockUser?.id}, isLoading=${isLoading}, error=${error?.message}`);

            // Only update Vue's Bedrock state data properties if Bedrock SDK is available
            if (!bedrockIsAvailable) {
                console.warn("Bedrock Passport SDK not available, skipping syncBedrockState updates.");
                this.isAuthProcessing = false; // Ensure loading state is false
                return;
            }


           // Update Vue's Bedrock state data properties
           this.bedrockIsAuthenticated = isAuthenticated;
           this.bedrockUser = bedrockUser;
           this.bedrockIsLoading = isLoading; // Keep Bedrock's specific loading state
           this.bedrockError = error; // Store the error object

           // Update the combined processing flag
           this.isAuthProcessing = this.bedrockIsLoading; // Simple sync for this demo


           // Handle user login/logout based on Bedrock state
           if (isAuthenticated && bedrockUser && bedrockUser.id) {
                // User is logged in via Bedrock and has a valid ID
                const bedrockId = bedrockUser.id;
                console.log(`Bedrock state synced: Logged in as User ID: ${bedrockId}`);

                // If currentUserIdentifier is not already set or doesn't match
                if (this.currentUserIdentifier !== bedrockId) {
                     console.log(`currentUserIdentifier changing from ${this.currentUserIdentifier} to ${bedrockId}. Loading PestiVid profile.`);
                    this.currentUserIdentifier = bedrockId; // Set PestiVid identifier to Bedrock ID

                     // Check/Load PestiVid Profile for this Bedrock ID
                    const userProfile = this.allUserProfiles[this.currentUserIdentifier];
                    if (!userProfile) {
                        console.log(`No PestiVid profile found for Bedrock ID ${this.currentUserIdentifier}. Initiating onboarding.`);
                        // New user - proceed to onboarding
                        this.role = ''; // Explicitly clear role for new users
                        // Pre-fill onboarding form with available Bedrock data
                        this.userName = bedrockUser.name || '';
                        this.userEmail = bedrockUser.email || '';
                        this.userPhone = ''; // Phone is PestiVid specific
                         // Set member since date on first connect if not set (or based on Bedrock data if available)
                         this.memberSince = new Date().toLocaleDateString(); // Always set on first connect

                         // Initialize onboarding form state
                        this.selectedRoleOnboarding = '';
                        this.userNameOnboarding = this.userName; // Pre-fill if Bedrock provided
                        this.userEmailOnboarding = this.userEmail; // Pre-fill if Bedrock provided
                        this.userPhoneOnboarding = '';
                        this.farmerLocationCityOnboarding = ''; // Clear for new user onboarding

                        this.filterDataForCurrentUser(); // Filter based on new currentUserIdentifier
                        // Redirection to roleSelection will happen via the isAuthProcessing watcher
                         console.log("Setting isAuthProcessing to true after user ID change to wait for profile load logic.");


                    } else {
                         console.log(`Existing PestiVid profile found for Bedrock ID ${this.currentUserIdentifier}. Loading profile.`);
                        // Existing user - load their PestiVid profile data
                        this.role = userProfile.role;
                        this.userName = userProfile.name;
                        this.userEmail = userProfile.email;
                        this.userPhone = userProfile.phone;
                        this.memberSince = userProfile.memberSince;
                        this.farmerLocationCity = userProfile.farmerLocationCity || '';

                         this.filterDataForCurrentUser(); // Filter data for the loaded user

                         // Redirection handled by isAuthProcessing watcher when it becomes false

                    }
                    this.saveDataToLocalStorage(); // Save updated user profiles (specifically the new one if just created)

                } else {
                     // currentUserIdentifier already matches the Bedrock ID.
                     // This happens on initial page load when Bedrock restores a session.
                     // Profile is already loaded from the previous state (in loadDataFromLocalStorage)
                     // or was just set in a previous syncState call.
                     console.log(`Bedrock state synced: Already logged in as ${this.currentUserIdentifier}. Profile state should be loaded.`);
                     // Ensure data is filtered, though it should be from initial loadDataFromLocalStorage or previous sync
                     this.filterDataForCurrentUser();
                      // Redirection handled by isAuthProcessing watcher when it becomes false
                }

           } else { // BedrockIsAuthenticated is false
                console.log("Bedrock state synced: Not authenticated.");
                // Clear currentUserIdentifier only if Bedrock explicitly says not authenticated
                if (!isLoading) { // Only clear if Bedrock is finished loading and not authenticated
                     if (this.currentUserIdentifier !== null) {
                          console.log(`Bedrock finished loading, not authenticated. currentUserIdentifier was ${this.currentUserIdentifier}, clearing PestiVid session.`);
                         // Was logged in, now logged out - clear PestiVid session
                         this.clearUserSession(true); // Clear PestiVid session and redirect
                     } else {
                          // Already logged out in PestiVid state, just ensure loginChoice is shown if needed
                          console.log("Bedrock finished loading, not authenticated, PestiVid state already logged out. No session clear needed.");
                          // Redirection handled by isAuthProcessing watcher becoming false
                     }
                } else {
                     // Bedrock is still loading, just update the state. Redirection will happen once loading is false.
                     console.log("Bedrock is still loading. Waiting for state sync to complete before acting.");
                }
           }

            console.log("End syncBedrockState. PestiVid State:", {
                currentUserIdentifier: this.currentUserIdentifier,
                role: this.role,
                bedrockIsAuthenticated: this.bedrockIsAuthenticated,
                bedrockIsLoading: this.bedrockIsLoading,
                isAuthProcessing: this.isAuthProcessing,
                currentVuePage: this.current,
            });
       },
       // This method is called by the AuthCallbackProcessor React component on successful login
       handleSuccessfulOrangeIdLogin(bedrockUser) {
            console.log("[Vue] handleSuccessfulOrangeIdLogin called with Bedrock User:", bedrockUser?.id);
            // The syncBedrockState watcher will handle the actual state update and redirection
            // based on bedrockIsAuthenticated becoming true and bedrockUser being set.
            // We simply ensure the syncBedrockState logic is aware of the successful login flow.
            // The AuthCallbackProcessor already navigates back to the root URL after processing.
            // The BedrockStateBridge will then pick up the authenticated state.
            // Redirect happens via the isAuthProcessing watcher becoming false after Bedrock isLoading becomes false.
       },
       handleLogoutClick() {
           console.log("Attempting to logout via Bedrock Passport...");
           // Check if Bedrock SDK is available before calling its logout
           if (!bedrockIsAvailable) {
               console.warn("Bedrock Passport SDK not available. Cannot call SDK logout. Clearing local session only.");
               this.clearUserSession(true); // Fallback to just clearing PestiVid session
               return;
           }

            if (this.$refs.bedrockBridge && this.$refs.bedrockBridge.logout) {
                this.showLoadingModal = true;
                this.loadingMessage = "Logging out...";
                this.$refs.bedrockBridge.logout(); // Call logout method exposed by the bridge component
                // The syncBedrockState watcher will detect the logout state change and trigger clearUserSession
            } else {
                 console.warn("Bedrock Bridge ref or logout method not available. Proceeding with local session clear.");
                 this.clearUserSession(true); // Fallback to just clearing PestiVid session
            }
       },
       clearUserSession(redirect = true) {
            console.log("Clearing PestiVid user session...");
           // Clear all PestiVid user-specific state and data
           this.currentUserIdentifier = null;
           this.role = '';
           this.userName = '';
           this.userEmail = '';
           this.userPhone = '';
           this.memberSince = '';
           this.farmerLocationCity = '';
            this.activeConversationId = null; // Clear active chat

           // Clear user-specific filtered data arrays
           this.filterDataForCurrentUser();

           this.saveDataToLocalStorage(); // Save cleared PestiVid state

            if (redirect) {
                this.switchPage('landing'); // Go back to landing page
            }
             console.log("PestiVid user session cleared.");
              // Notification is added by the bedrockIsAuthenticated watcher (when it goes false)
       },
       // This method renders the appropriate Bedrock React component on the loginChoice page
       renderBedrockLoginWidget() {
           console.log("Rendering Bedrock Login Widget on loginChoice page...");
            const container = document.getElementById('bedrock-react-container');
           if (!container || !this.bedrockReactRoot || !bedrockIsAvailable) { // Check if React root exists and SDK is available
                console.error("Bedrock login container, React root, or SDK not found. Cannot render widget.");
                 // Optionally render an error message in the container
                 if(container) container.innerHTML = '<div style="color: red; text-align: center;">Error loading authentication widget. Please check your internet connection.</div>';
                return;
           }

           // Check if we are currently processing a callback
           const params = new URLSearchParams(window.location.search);
           const isCallback = params.has('token') && params.has('refreshToken');

            // Render either the callback processor or the login panel
           if (isCallback) {
                console.log("Callback parameters detected. Rendering AuthCallbackProcessor.");
                // AuthCallbackProcessor must be rendered within BedrockPassportProvider context
                // Since the Provider is global, we just render the component.
                this.bedrockReactRoot.render(
                     React.createElement(AuthCallbackProcessor, { vueApp: this }) // Pass Vue instance
                 );
           } else {
                console.log("No callback parameters. Rendering LoginPanel.");
                // PestiVidLoginPanelWrapper must be rendered within BedrockPassportProvider context
                // Since the Provider is global, we just render the wrapper component.
                this.bedrockReactRoot.render(
                     React.createElement(PestiVidLoginPanelWrapper) // Render the LoginPanel wrapper
                 );
           }
       },
       // This method unmounts the React component from the loginChoice page container
       unmountBedrockLoginWidget() {
            if (this.bedrockReactRoot) {
                console.log("Unmounting Bedrock Login Widget.");
                this.bedrockReactRoot.unmount();
                // Clear the container's content just in case
                const container = document.getElementById('bedrock-react-container');
                if (container) container.innerHTML = '';
            }
       },


      // --- Local Storage Data Persistence (Simulated Backend) ---
      loadDataFromLocalStorage() {
          console.log("Loading data from localStorage...");
          try {
              const storedData = localStorage.getItem('pestiVidData');
              if (storedData) {
                  const data = JSON.parse(storedData);
                  this.allFarmerVideos = data.allFarmerVideos || [];
                  this.allListings = data.allListings || [];
                  this.allFundingRequests = data.allFundingRequests || [];
                  this.allBuyerPurchases = data.allBuyerPurchases || [];
                  this.allInvestorInvestments = data.allInvestorInvestments || [];
                  this.allInvestorTransactions = data.allInvestorTransactions || [];
                  this.allConversations = data.allConversations || [];
                  this.allMessages = data.allMessages || [];
                  this.allUserProfiles = data.allUserProfiles || {};
                   // currentUserIdentifier and other profile data will be set by syncBedrockState on load

                   console.log("Data loaded from localStorage.", { numVideos: this.allFarmerVideos.length, numListings: this.allListings.length, numFunding: this.allFundingRequests.length, numProfiles: Object.keys(this.allUserProfiles).length });

              } else {
                  console.log("No data found in localStorage. Starting fresh.");
                  // Initialize empty structures if no data is found
                  this.allFarmerVideos = []; this.allListings = []; this.allFundingRequests = [];
                  this.allBuyerPurchases = []; this.allInvestorInvestments = [];
                  this.allInvestorTransactions = []; this.allConversations = []; this.allMessages = [];
                  this.allUserProfiles = {};
              }
               // Always filter data initially based on potentially restored currentUserIdentifier
               this.filterDataForCurrentUser(); // filterDataForCurrentUser is called here instead of syncBedrockState's initial load

          } catch (e) {
              console.error("Failed to load data from localStorage:", e);
              // Reset to empty state on error
              this.allFarmerVideos = []; this.allListings = []; this.allFundingRequests = [];
              this.allBuyerPurchases = []; this.allInvestorInvestments = [];
              this.allInvestorTransactions = []; this.allConversations = []; this.allMessages = [];
              this.allUserProfiles = {};
              this.clearUserSession(false); // Clear any partial user session data but don't redirect yet
              this.addNotification("Failed to load application data from local storage.", "error");
          }
      },
      saveDataToLocalStorage() {
           console.log("Saving data to localStorage...");
          try {
               // Collect all global data arrays and the user profiles map
              const dataToSave = {
                  allFarmerVideos: this.allFarmerVideos,
                  allListings: this.allListings,
                  allFundingRequests: this.allFundingRequests,
                  allBuyerPurchases: this.allBuyerPurchases,
                  allInvestorInvestments: this.allInvestorInvestments,
                  allInvestorTransactions: this.allInvestorTransactions,
                  allConversations: this.allConversations,
                  allMessages: this.allMessages,
                  allUserProfiles: this.allUserProfiles,
              };
              localStorage.setItem('pestiVidData', JSON.stringify(dataToSave));
               console.log("Data saved.");
          } catch (e) {
              console.error("Failed to save data to localStorage:", e);
               this.addNotification("Failed to save application data.", "error");
          }
      },
      filterDataForCurrentUser() {
          // Filters the global data arrays to populate the current user's specific arrays
          console.log(`Filtering data for user: ${this.currentUserIdentifier || 'none'}, role: ${this.role || 'none'}`);
          if (this.currentUserIdentifier) {
              this.farmerVideos = this.allFarmerVideos.filter(v => v.farmerWallet === this.currentUserIdentifier);
              this.farmerListings = this.allListings.filter(l => l.farmerWallet === this.currentUserIdentifier);
              this.farmerFundingRequests = this.allFundingRequests.filter(r => r.farmerWallet === this.currentUserIdentifier);
              this.buyerPurchases = this.allBuyerPurchases.filter(p => p.buyerWallet === this.currentUserIdentifier);
              this.investorInvestments = this.allInvestorInvestments.filter(inv => inv.investorWallet === this.currentUserIdentifier);
              this.investorTransactions = this.allInvestorTransactions.filter(tx => tx.investorWallet === this.currentUserIdentifier);
              // Filter conversations: involves current user in participants list
              this.conversations = this.allConversations.filter(conv => conv.participants.includes(this.currentUserIdentifier));
              // Filter messages: only messages from conversations the user is in
              const userConvIds = new Set(this.conversations.map(c => c.id));
              this.messages = this.allMessages.filter(msg => userConvIds.has(msg.conversationId));

              console.log(`User data filtered: Videos(${this.farmerVideos.length}), Listings(${this.farmerListings.length}), Funding(${this.farmerFundingRequests.length}), Purchases(${this.buyerPurchases.length}), Investments(${this.investorInvestments.length}), Transactions(${this.investorTransactions.length}), Conversations(${this.conversations.length}), Messages(${this.messages.length})`);

          } else {
              // Clear user-specific arrays if no user is logged in
              this.farmerVideos = [];
              this.farmerListings = [];
              this.farmerFundingRequests = [];
              this.buyerPurchases = [];
              this.investorInvestments = [];
              this.investorTransactions = [];
              this.conversations = [];
              this.messages = [];
               this.activeConversationId = null; // Clear active chat
          }
      },
       updateInvestmentProgress() {
           // Simulate investment progress based on time passed
           const now = Date.now();
           let dataChanged = false;

           // Only update if Bedrock SDK is available and user is authenticated (to avoid errors)
           if (!bedrockIsAvailable || !this.bedrockIsAuthenticated) {
               console.warn("Skipping updateInvestmentProgress: SDK not available or user not authenticated.");
               return;
           }


           this.allFundingRequests.forEach(project => {
               // Find corresponding investments for this project
               const investmentsInProject = this.allInvestorInvestments.filter(inv => inv.projectId === project.id);

               // Update project progress (simple simulation: linear over timeline)
               if (project.status !== 'funded' && project.status !== 'harvested' && project.status !== 'cancelled' && project.simStartDate && project.timeline > 0) {
                   const startDate = new Date(project.simStartDate).getTime();
                   const totalDurationMs = project.timeline * 30 * 24 * 60 * 60 * 1000; // Approximate months to milliseconds
                   const elapsedMs = now - startDate;
                   let progress = Math.min(100, (elapsedMs / totalDurationMs) * 100);

                   // Only update if progress has significantly changed (e.g., by at least 1%)
                   if (Math.abs(progress - (project.progress || 0)) >= 0.5) { // Use 0.5% tolerance
                       console.log(`Updating progress for project ${project.id}: ${(project.progress || 0).toFixed(1)}% -> ${progress.toFixed(1)}%`);
                       this.$set(project, 'progress', parseFloat(progress.toFixed(1))); // Update progress reactively
                       dataChanged = true; // Mark data as changed

                       // Simulate harvest completion if 100% reached or exceeded
                        if (progress >= 99.9 && project.status !== 'harvested') { // Use 99.9 threshold to handle potential float issues
                           console.log(`Simulating harvest completion for project: ${project.title}`);
                           this.$set(project, 'status', 'harvested');
                            this.$set(project, 'progress', 100); // Ensure it's exactly 100
                           dataChanged = true;

                           // Simulate payout (only if investors exist and payouts haven't been done for this project)
                            const hasInvestors = project.investors && project.investors.length > 0;
                            const payoutsDone = this.allInvestorTransactions.some(tx => tx.projectId === project.id && tx.type === 'payout');
                            if (hasInvestors && !payoutsDone) {
                                console.log(`Triggering payout simulation for project ${project.id}.`);
                                this.simulatePayout(project); // This also sets dataChanged if payouts are added
                                dataChanged = true; // Ensure flag is set if payout simulated
                            } else if (hasInvestors && payoutsDone) {
                                 console.log(`Payouts for project ${project.id} already simulated.`);
                            } else {
                                 console.log(`Project ${project.id} harvested but no investors to pay out.`);
                            }
                       }
                   }
               } else if (project.status === 'harvested' && (project.progress || 0) < 100) {
                    // Ensure harvested projects are marked 100%
                     this.$set(project, 'progress', 100);
                     dataChanged = true;
               } else if (project.status === 'cancelled' && (project.progress || 0) > 0) {
                    // Ensure cancelled projects are marked 0%
                     this.$set(project, 'progress', 0);
                     dataChanged = true;
               }

               // Update status and progress for each individual investment in this project
               investmentsInProject.forEach(investment => {
                    // The investment status usually follows the project status, but 'growing' is specific to investor view of active projects
                   let investmentStatus = project.status;
                   if (investmentStatus === 'funded' || investmentStatus === 'partially_funded') {
                       investmentStatus = 'growing'; // Investor sees these as "growing" until harvested
                   }

                   if (investment.status !== investmentStatus) {
                         this.$set(investment, 'status', investmentStatus);
                         dataChanged = true;
                    }
                    // Update investment's progress based on the project's progress
                   if (investment.progress !== project.progress) {
                       this.$set(investment, 'progress', project.progress);
                       dataChanged = true;
                   }
               });
           });

           // Re-filter investor data after updating progress IF the current user is an investor
           // This ensures the computed properties and displayed lists are up-to-date
           if (this.bedrockIsAuthenticated && this.role === 'investor') {
                // Manually update investorInvestments from the potentially modified allInvestorInvestments
                // Re-filtering is the safest way to ensure the list is correct
               this.investorInvestments = this.allInvestorInvestments.filter(inv => inv.investorWallet === this.currentUserIdentifier);
               // Sort investorInvestments by date or status for better display (optional)
                this.investorInvestments.sort((a, b) => {
                    // Sort active/growing first, then by investment date
                     const statusOrder = { 'active': 1, 'partially_funded': 2, 'growing': 3, 'funded': 4, 'pending': 5, 'cancelled': 6, 'harvested': 7 }; // Define status order
                     const statusA = statusOrder[a.status] || 10;
                     const statusB = statusOrder[b.status] || 10;

                     if (statusA !== statusB) return statusA - statusB;

                     // If statuses are the same, sort by investment date (newest first)
                     return new Date(b.investmentDate).getTime() - new Date(a.investmentDate).getTime();
                });
           }
            // Also re-filter farmer funding requests if the current user is a farmer
            if (this.bedrockIsAuthenticated && this.role === 'farmer') {
                 this.farmerFundingRequests = this.allFundingRequests.filter(r => r.farmerWallet === this.currentUserIdentifier);
                 // Sort farmerFundingRequests (e.g., by status or creation date)
                 this.farmerFundingRequests.sort((a, b) => {
                    const statusOrder = { 'pending': 1, 'partially_funded': 2, 'funded': 3, 'growing': 4, 'cancelled': 5, 'harvested': 6 }; // Define status order
                     const statusA = statusOrder[a.status] || 10;
                     const statusB = statusOrder[b.status] || 10;
                     if (statusA !== statusB) return statusA - statusB;

                     // If statuses are the same, sort by creation date (newest first)
                     return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
                 });
            }
            // Re-filter user conversations as last message timestamp might change
            if (this.bedrockIsAuthenticated) {
                 const userConvIds = new Set(this.allConversations.filter(conv => conv.participants.includes(this.currentUserIdentifier)).map(c => c.id));
                 this.messages = this.allMessages.filter(msg => userConvIds.has(msg.conversationId)); // Update messages for current user's conversations
                 // The userConversations computed property automatically rebuilds and sorts based on allConversations and allMessages changes
            }


           if (dataChanged) {
             this.saveDataToLocalStorage(); // Save updated progress/status/payouts
           } else {
              console.log("No significant progress updates detected for saving.");
           }
       },
        simulatePayout(project) {
           // Simulate paying out investors when a project harvests (reaches 100% progress or is manually marked)
           if (!project || project.status !== 'harvested' || !project.investors || project.investors.length === 0) {
               console.warn(`SimulatePayout called for ineligible project ${project?.id || 'N/A'}. Status: ${project?.status}, Investors: ${project?.investors?.length || 0}`);
               return; // Only process harvested projects with investors
           }
           console.log(`Simulating payout for project: "${project.title}" (ID: ${project.id})`);

            // Check if payouts for this project were already simulated
            const alreadyPaidOut = this.allInvestorTransactions.some(tx => tx.projectId === project.id && tx.type === 'payout');
            if (alreadyPaidOut) {
                console.log(`Payout already simulated for project ${project.id}. Skipping.`);
                return;
            }


           const totalFunded = project.fundedAmount || 0;
           if (totalFunded <= 0) {
               console.warn(`Project ${project.id} is harvested but has <= 0 fundedAmount. No payouts.`);
                return;
           }

           // Simulate payout for each investor
           project.investors.forEach(inv => {
               const investorAmount = inv.amount || 0;
               if (investorAmount <= 0) return; // Skip investors who invested 0 or less

               // Find the specific investment record for this investor in this project to get the exact ROI/Share terms they invested under
               const investmentRecord = this.allInvestorInvestments.find(i => i.projectId === project.id && i.investorWallet === inv.investorId);

               // Calculate the investor's expected total return based on their investment amount and the *project's* ROI/Investor Share
               // Using project's ROI/Share ensures all investors in the same project get payouts based on the same terms,
               // even if those terms were changed on the project *after* some initial investments were made.
               // The calculateExpectedReturn function is intended for portfolio display *based on the investment record's terms*.
               // For payout, we should use the project's final ROI and Investor Share at the time of harvest simulation.
               // HOWEVER, for this demo, calculateExpectedReturn using the *investment's* terms is simpler and avoids tracking project term changes.
               // Let's stick to using the investment record's terms for payout calculation consistency with portfolio display.

               const estimatedPayoutAmount = parseFloat(this.calculateExpectedReturn(investmentRecord || { amount: investorAmount, roi: project.roi, investorShare: project.investorShare })); // Fallback to project terms if investment record not found (shouldn't happen if data is consistent)


               console.log(`  - Investor ${this.getDisplayIdentifier(inv.investorId, 10)} invested ${investorAmount.toFixed(2)} SOL. Simulating payout of ${estimatedPayoutAmount.toFixed(2)} SOL`);

               const payoutTxHash = 'sim_payout_tx_' + Date.now().toString(16) + '_' + inv.investorId.substring(0, 6) + Math.random().toString(16).substring(2,6);
               const payoutTx = {
                    id: 'txp' + Date.now() + '_' + inv.investorId.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                    investorWallet: inv.investorId,
                    txHash: payoutTxHash,
                    type: 'payout', // Transaction type
                    amount: estimatedPayoutAmount, // The total amount paid out
                    date: new Date().toLocaleDateString(),
                    projectId: project.id,
                    projectTitle: project.title,
                    notes: `Harvest payout for project "${project.title}"`
               };
               this.allInvestorTransactions.unshift(payoutTx); // Add to global transactions

               // If the user receiving payout is the current user, trigger notification
                if (inv.investorId === this.currentUserIdentifier) {
                    // The investorTransactions filtered list will update automatically
                     this.addNotification(`Harvest Payout received for "${project.title}"! You received ${payoutTx.amount} SOL.`, 'success');
                } else {
                     // Add notification for non-current user investors if they load their profile later
                      this.addNotification(`Harvest Payout processed for "${project.title}".`, 'info', inv.investorId); // Use info type for passive notification, filtered by recipient
                }
           });
           // Sort global transactions after adding payouts
           this.allInvestorTransactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

            // Data changed flag is set in updateInvestmentProgress if this function is called from there.
            // If called manually, you'd need to set dataChanged = true here before saving.
            // Relying on updateInvestmentProgress for now.
            // this.saveDataToLocalStorage(); // Save updated transactions
        },


        // --- Messaging ---
        getOtherParticipantIdentifier(conversation) {
            // Get the wallet/ID of the other participant in a conversation
            if (!conversation || !this.currentUserIdentifier) return null;
            return conversation.participants.find(p => p !== this.currentUserIdentifier);
        },
        getOtherParticipantDisplayAddress(conversation) {
            // Get the display name for the other participant in a conversation
            const partnerId = this.getOtherParticipantIdentifier(conversation);
            if (!partnerId) return '?';
            return this.getDisplayIdentifier(partnerId); // Use the general helper
        },
         getOtherParticipantInitial(conversation) {
             // Get the first initial of the other participant's display name
             const partnerDisplay = this.getOtherParticipantDisplayAddress(conversation);
             if (!partnerDisplay || partnerDisplay === '?' || partnerDisplay === 'N/A') return '?';
            return partnerDisplay.charAt(0).toUpperCase();
         },
        startOrGoToConversation(partnerIdentifier) {
            // Finds an existing conversation with a partner or creates a new one, then switches to messaging view
            if (!this.bedrockIsAuthenticated || !this.currentUserIdentifier) { // Check Bedrock auth status
                this.addNotification("You must be logged in to message users.", "error");
                this.switchPage('loginChoice');
                return;
            }
            if (this.currentUserIdentifier === partnerIdentifier) {
                 this.addNotification("You cannot message yourself.", "warning");
                 // Optionally redirect to user profile
                 this.switchPage('userProfile');
                 return;
             }
             if (!this.allUserProfiles[partnerIdentifier]) {
                  this.addNotification("User profile not found for this identifier. Cannot start conversation.", "error");
                  console.error(`Attempted to message non-existent user profile: ${partnerIdentifier}`);
                  return;
             }


            console.log(`Attempting to start or go to conversation with ${partnerIdentifier}`);

            // Find existing conversation
            let existingConv = this.allConversations.find(conv =>
                conv.participants.includes(this.currentUserIdentifier) &&
                conv.participants.includes(partnerIdentifier)
            );

            if (existingConv) {
                console.log(`Found existing conversation: ${existingConv.id}`);
                this.selectConversation(existingConv.id);
            } else {
                // Create a new conversation
                const newConv = {
                    id: 'conv' + Date.now() + '_' + this.currentUserIdentifier.substring(0,4) + partnerIdentifier.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                    participants: [this.currentUserIdentifier, partnerIdentifier],
                    createdAt: new Date().toISOString(),
                    lastMessageTimestamp: new Date().toISOString(), // Set to creation time initially
                    lastMessageSnippet: 'Conversation started.',
                };
                 console.log(`Creating new conversation: ${newConv.id}`);
                this.allConversations.unshift(newConv); // Add to global conversations
                // Filtered list (`this.conversations`) will update automatically due to computed prop

                this.selectConversation(newConv.id); // Select the new conversation
                this.saveDataToLocalStorage(); // Save the new conversation
                this.addNotification(`New conversation started with ${this.getDisplayIdentifier(partnerIdentifier, 10)}.`, 'info'); // Use general display helper
            }

            // Switch to the messaging page
            this.switchPage('messaging');
        },
        selectConversation(conversationId) {
            // Sets the active conversation and marks unread messages as read
            if (!this.bedrockIsAuthenticated || !this.currentUserIdentifier) { // Check Bedrock auth
                this.addNotification("Please log in to view messages.", "error");
                return;
            }
             console.log(`Selecting conversation: ${conversationId}`);
            this.activeConversationId = conversationId;
            this.messageInputText = ''; // Clear input when changing conversations

            // Mark messages in this conversation as read for the current user
             // Use nextTick to ensure messages are rendered before attempting to mark as read
            this.$nextTick(() => {
                this.markConversationAsRead(conversationId);
                 // Scroll to the bottom of the message container after selecting and rendering messages
                 this.scrollToMessageBottom(); // Called inside markConversationAsRead's nextTick
            });


        },
        markConversationAsRead(conversationId) {
             // Marks all unread messages in a conversation as read for the current user
             // Use nextTick to ensure DOM update is potentially complete if called after receiving new messages
             this.$nextTick(() => {
                 let messagesMarkedRead = 0;
                 if (!this.currentUserIdentifier) return 0; // Cannot mark as read if no user

                 // Find messages in the active conversation that are addressed to the current user and are unread
                 this.allMessages.forEach(msg => {
                     if (msg.conversationId === conversationId && msg.receiver === this.currentUserIdentifier && !msg.read) {
                          // Use $set for reactivity in Vue 2
                          this.$set(msg, 'read', true);
                          messagesMarkedRead++;
                     }
                 });

                  if (messagesMarkedRead > 0) {
                      console.log(`Marked ${messagesMarkedRead} messages as read in conversation ${conversationId}.`);
                      this.saveDataToLocalStorage(); // Save changes
                  }
                  return messagesMarkedRead; // Return count for potential use
             });
         },
         getUnreadCountForConversation(conversationId) {
             // Helper to get unread count for a specific conversation (used by computed prop)
              if (!this.bedrockIsAuthenticated || !this.allMessages || !this.currentUserIdentifier) return 0;
              return this.allMessages.filter(msg => msg.conversationId === conversationId && msg.receiver === this.currentUserIdentifier && !msg.read).length;
         },
        sendMessage() {
            // Sends a new message in the active conversation (simulated)
            if (!this.bedrockIsAuthenticated || !this.currentUserIdentifier || !this.activeConversationId || !this.messageInputText.trim()) { // Check Bedrock auth
                return; // Don't send empty messages or if not authenticated/no active chat
            }
            console.log(`Sending message in conversation ${this.activeConversationId}...`);

            const messageText = this.messageInputText.trim();
            const now = new Date().toISOString();

            const newMessage = {
                id: 'msg' + Date.now() + '_' + Math.random().toString(16).substring(2, 8), // Unique ID
                conversationId: this.activeConversationId,
                sender: this.currentUserIdentifier,
                receiver: this.activeConversationPartnerIdentifier, // The other person in the chat
                text: messageText,
                timestamp: now,
                read: false, // Mark as unread for the receiver
            };

            this.allMessages.push(newMessage); // Add to global messages
            // currentMessages computed property will update automatically

             // Find the conversation in the global list and update last message info
            const conv = this.allConversations.find(c => c.id === this.activeConversationId);
            if (conv) {
                 // Use $set for reactivity in Vue 2
                this.$set(conv, 'lastMessageTimestamp', now);
                this.$set(conv, 'lastMessageSnippet', messageText.length > 50 ? messageText.substring(0, 47) + '...' : messageText);
                 console.log(`Updated conversation ${conv.id} last message info.`);
            } else {
                 console.warn(`Active conversation ${this.activeConversationId} not found in allConversations array.`);
            }

            this.messageInputText = ''; // Clear input field
            this.saveDataToLocalStorage(); // Save updated data

             // Scroll to the bottom to show the new message (handled by currentMessages watcher)

             // Simulate a notification for the receiver (if not the current user)
             const recipientProfile = this.allUserProfiles[newMessage.receiver];
             if (recipientProfile && recipientProfile.walletAddress !== this.currentUserIdentifier) {
                  // Pass the recipientIdentifier to addNotification
                  this.addNotification(`New message from ${this.userName ? this.userName.split(' ')[0] : this.getDisplayIdentifier(this.currentUserIdentifier, 10)} in chat.`, 'info', newMessage.receiver);
             }
        },
        scrollToMessageBottom() {
             // Scroll the message container to the bottom
             const container = this.$refs.messageContainer;
             if (container) {
                  // Wait for messages to render before scrolling
                  this.$nextTick(() => {
                    container.scrollTop = container.scrollHeight;
                 });
             }
         },
         formatTimestamp(timestamp, short = false) {
            // Format timestamp for message display
            if (!timestamp) return '';
            const date = new Date(timestamp);
            if (isNaN(date.getTime())) return timestamp; // Return original if invalid date

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();

            const oneDay = 24 * 60 * 60 * 1000;

            if (short) { // For conversation list (e.g., "10:30 AM", "Yesterday", "12/15/2023")
                 if (messageDate >= today) return date.toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'}).replace(' ', ''); // Today (>= today's start) - remove space before AM/PM
                 if (messageDate >= (today - oneDay)) return 'Yesterday'; // Yesterday
                 return date.toLocaleDateString(); // Older than yesterday
            } else { // For message view (e.g., "Dec 15, 10:30 AM")
                const options = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' };
                 if (date.getFullYear() !== now.getFullYear()) { // Add year if not current year
                     options.year = 'numeric';
                 }
                return date.toLocaleString([], options);
            }
        },
        messageFarmerFromProfile(farmerWallet) {
            // Helper to start/go to conversation when viewing a farmer's profile
             this.closeFarmerProfileModal(); // Close the profile modal
             this.$nextTick(() => { // Wait for modal to close before navigating/opening chat
                 this.startOrGoToConversation(farmerWallet);
             });
        },

        // --- Notifications ---
        addNotification(message, type = 'info', recipientIdentifier = null) {
             // Adds a notification to the queue. If recipientIdentifier is specified,
             // it only shows to the user matching that identifier. If null, shows to current user.
             // In this simplified demo, we only show notifications to the *current* user.
             // We filter by recipientIdentifier == this.currentUserIdentifier or recipientIdentifier == null.

             // Only add notification if the recipient is the current logged-in user or recipientIdentifier is null (intended for current user)
             if (this.bedrockIsAuthenticated && this.currentUserIdentifier && (recipientIdentifier === this.currentUserIdentifier || recipientIdentifier === null)) {
                  console.log(`Adding notification (${type}) for current user ${this.currentUserIdentifier}: ${message}`);
                 const id = Date.now() + '_' + Math.random().toString(16).substring(2, 10);
                 this.notifications.push({ id, message, type, show: false });

                 // Automatically trigger showing the next toast if there's space
                 // The watcher on `notifications` array already does this.
             } else if (recipientIdentifier && recipientIdentifier !== this.currentUserIdentifier) {
                  // console.log(`Notification intended for ${recipientIdentifier}: "${message}". Not showing to current user ${this.currentUserIdentifier || 'none'}.`);
                  // Do nothing if the recipient is not the current user
             } else if (!this.bedrockIsAuthenticated && recipientIdentifier === null) {
                 // Allow general notifications (type info, null recipient) even if not logged in (e.g., API key warnings)
                  console.log(`Adding general notification (${type}): ${message}`);
                  const id = Date.now() + '_' + Math.random().toString(16).substring(2, 10);
                  this.notifications.push({ id, message, type, show: false });
             } else {
                  // Case where recipientIdentifier is not null AND not authenticated - ignore for now
                  console.log(`Ignoring notification (${type}): "${message}" - not authenticated and recipient specified.`);
             }
        },
        showNextToastNotification() {
             // Shows the next notification in the queue if there's space
             if (this.recentNotifications.length >= 3 || this.notifications.length === 0) {
                 // Queue is empty or maximum toasts are already shown
                 return;
             }

             const nextNotification = this.notifications.shift(); // Get the first notification from the queue
             this.recentNotifications.unshift(nextNotification); // Add to the beginning of the recent list

             // Use nextTick to ensure the element is in the DOM before adding the 'show' class
             this.$nextTick(() => {
                 // Find the element by its data attribute or key
                 const element = this.$el.querySelector(`.notification-toast[data-notif-id='${nextNotification.id}']`);
                 if (element) {
                     // Use Vue.$set for reactivity on the object in the array
                     const index = this.recentNotifications.findIndex(n => n.id === nextNotification.id);
                     if (index !== -1) {
                        this.$set(this.recentNotifications[index], 'show', true);
                        // Auto-dismiss after a timeout
                        setTimeout(() => this.dismissNotification(nextNotification.id), this.notificationTimeout);
                     } else {
                         console.warn(`Notification index not found for ID ${nextNotification.id} after unshift.`);
                         // Fallback: try removing by id if index failed
                          const failIndex = this.recentNotifications.findIndex(n => n.id === nextNotification.id);
                           if (failIndex !== -1) this.recentNotifications.splice(failIndex, 1);
                     }
                 } else {
                      console.warn(`Notification element not found for ID ${nextNotification.id}. Cannot show toast.`);
                       // Remove from recentNotifications if element wasn't found to prevent block
                        const failIndex = this.recentNotifications.findIndex(n => n.id === nextNotification.id);
                         if (failIndex !== -1) this.recentNotifications.splice(failIndex, 1);
                         // Try showing the next one in case this one was stuck
                         this.showNextToastNotification();
                 }
             });
        },
        dismissNotification(id) {
            // Dismisses a specific notification and triggers showing the next one
            const index = this.recentNotifications.findIndex(n => n.id === id);
            if (index !== -1) {
                // Hide the element first with transition
                this.$set(this.recentNotifications[index], 'show', false);
                // Remove from the list after the transition duration (adjust timeout if needed)
                setTimeout(() => {
                    this.recentNotifications.splice(index, 1);
                    // Show the next notification immediately after one is dismissed
                    this.showNextToastNotification();
                }, 400); // Match CSS transition duration
            }
        },


        // --- Farmer Profile & Other User Info ---
        showFarmerProfile(walletAddress) {
            // Find the farmer's profile data and display the modal
             console.log(`Attempting to show profile for wallet: ${walletAddress}`);
            if (!walletAddress) {
                this.addNotification("Cannot show profile: Wallet address is missing.", "warning");
                return;
            }

            const profile = this.allUserProfiles[walletAddress];

            if (profile && profile.role === 'farmer') {
                // Augment profile data with activity counts for display
                 const farmerData = {
                     walletAddress: walletAddress,
                     name: profile.name,
                     email: profile.email,
                     phone: profile.phone,
                     memberSince: profile.memberSince,
                     bio: profile.bio || 'No bio provided.', // Add a simulated bio field
                     // Count their current active items in the global lists
                     activeListingCount: this.allListings.filter(l => l.farmerWallet === walletAddress && l.status === 'active').length,
                     fundingRequestCount: this.allFundingRequests.filter(r => r.farmerWallet === walletAddress && (r.status === 'pending' || r.status === 'partially_funded')).length,
                     // Add other simulated info if needed
                 };
                this.selectedFarmerProfile = farmerData;
                this.showFarmerProfileModal = true;
                 console.log("Farmer profile data:", farmerData);
            } else {
                console.warn(`Profile not found or not a farmer for wallet: ${walletAddress}`);
                 // Show a notification if the profile isn't found or isn't a farmer
                 if (profile && profile.role) {
                      this.addNotification(`User ${this.getDisplayIdentifier(walletAddress, 10)} is a ${profile.role}. Profile details limited.`, 'info');
                      // Optionally show a basic modal with just the available info
                       const basicProfile = {
                         walletAddress: walletAddress,
                         name: profile.name || this.getDisplayIdentifier(walletAddress, 10),
                         email: profile.email || 'N/A',
                         phone: profile.phone || 'N/A',
                         memberSince: profile.memberSince || 'N/A',
                         bio: profile.bio || `This user's primary role is ${profile.role}. Bio not available.`,
                         activeListingCount: 0, fundingRequestCount: 0 // No farmer activity counts
                       };
                       this.selectedFarmerProfile = basicProfile;
                       this.showFarmerProfileModal = true;

                 } else {
                    this.addNotification(`Profile not found for identifier: ${this.getDisplayIdentifier(walletAddress, 10)}.`, 'warning');
                 }
            }
        },
        closeFarmerProfileModal() {
            // Close the farmer profile modal
            this.showFarmerProfileModal = false;
            this.selectedFarmerProfile = null;
             console.log("Farmer profile modal closed.");
        },

         // Helper to get display name for any user identifier (uses PestiVid name first, then Bedrock bedrockId, then Bedrock email, then truncates Bedrock id)
         getDisplayIdentifier(identifier, truncateLength = 6) {
             if (!identifier) return 'N/A';
             const profile = this.allUserProfiles[identifier];

             // 1. Use PestiVid name if available and not empty
             if (profile && profile.name && profile.name.trim()) {
                 return profile.name;
             }

             // Find the corresponding Bedrock user object (might be the current user or another user)
             const bedrockUserData = (this.bedrockUser && this.bedrockUser.id === identifier) ? this.bedrockUser :
                                    Object.values(this.allUserProfiles).find(p => p.walletAddress === identifier && p.bedrockId); // Check other profiles if they stored bedrockId

             // 2. Use Bedrock bedrockId if available and not 'N/A'
             if (bedrockUserData && bedrockUserData.bedrockId && bedrockUserData.bedrockId !== 'N/A') {
                  const bedrockId = String(bedrockUserData.bedrockId);
                  // Truncate bedrockId only if it's very long
                  if (bedrockId.length > truncateLength + 4) return `${bedrockId.substring(0, truncateLength)}...${bedrockId.substring(bedrockId.length - 4)}`;
                  return bedrockId;
             }

             // 3. Use Bedrock email if available and not empty
             if (bedrockUserData && bedrockUserData.email && bedrockUserData.email.trim()) {
                 return bedrockUserData.email;
             }

             // 4. Fallback to truncated PestiVid identifier (which is the Bedrock ID)
             const id = String(identifier);
             if (id.length > truncateLength + 4) return `${id.substring(0, truncateLength)}...${id.substring(id.length - 4)}`;
             return id;
         },
        getFarmerDisplayIdentifier(walletAddress, truncateLength = 6) {
            // Specific helper for farmers, same logic as getDisplayIdentifier for now
            return this.getDisplayIdentifier(walletAddress, truncateLength);
        },
         getSellerDisplayIdentifier(walletAddress, truncateLength = 6) {
            // Specific helper for sellers (farmers), same logic
             return this.getDisplayIdentifier(walletAddress, truncateLength);
         },


        // --- Weather Feature (Farmer Profile) ---
        async fetchWeather() {
            // Fetch current weather and forecast for the farmer's location using OpenWeatherMap
            if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) return; // Should be gated by UI and auth
            if (!this.farmerLocationCity.trim()) {
                 this.weatherError = "Please enter a city name.";
                 this.currentWeather = null; this.forecastWeather = [];
                 this.addNotification(this.weatherError, "warning");
                 return;
            }
             // Check API key configuration
             if (this.weatherApiKey === 'YOUR_OPENWEATHERMAP_API_KEY' || !this.weatherApiKey || this.weatherApiKey.includes('YOUR_')) {
                 this.weatherError = "OpenWeatherMap API key is not configured. Please replace the placeholder in the code.";
                 this.currentWeather = null; this.forecastWeather = [];
                 console.error("OpenWeatherMap API Key Error:", this.weatherApiKey);
                 this.addNotification(this.weatherError, "error");
                 return;
             }


            this.weatherLoading = true;
            this.weatherError = '';
            this.currentWeather = null;
            this.forecastWeather = [];

            const city = this.farmerLocationCity.trim();
            const units = 'metric'; // or 'imperial' for Fahrenheit

            try {
                // Step 1: Get coordinates for the city (Geocoding API)
                const geoResponse = await axios.get(`https://api.openweathermap.org/geo/1.0/direct?q=${city}&limit=1&appid=${this.weatherApiKey}`);
                if (geoResponse.data && geoResponse.data.length > 0) {
                    const { lat, lon, name, country } = geoResponse.data[0];
                    console.log(`Geocoded ${city}: Lat ${lat}, Lon ${lon}`);
                    // Use the API's returned name for display, as it's often cleaner
                    const displayLocationName = `${name}, ${country}`;


                    // Step 2: Get current weather and 5-day forecast using the coordinates
                    // Using 'onecall' with 'current' and 'daily' excludes unnecessary data like minutely/hourly
                    const weatherResponse = await axios.get(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&exclude=minutely,hourly,alerts&units=${units}&appid=${this.weatherApiKey}`);
                    const data = weatherResponse.data;

                    console.log("Weather data received:", data);

                     // Update current weather
                    if (data.current) {
                         this.currentWeather = {
                             ...this.currentWeather, // Keep name from geo data
                             name: displayLocationName, // Ensure display name is set here
                             main: data.current.temp ? {temp: data.current.temp, humidity: data.current.humidity, pressure: data.current.pressure} : null, // Use temp, humidity, pressure directly from 'current' if available
                             weather: data.current.weather,
                             wind: data.current.wind_speed ? { speed: data.current.wind_speed, deg: data.current.wind_deg } : null,
                             sys: data.current.sys, // Not available in onecall current - remove or adapt if needed. Leaving for now but might be null.
                             visibility: data.current.visibility,
                             dt: data.current.dt // Timestamp
                         };
                         console.log("Current weather updated.");
                    } else {
                         this.weatherError = "Could not retrieve current weather data for this location.";
                          console.warn("Current weather data missing in OneCall API response:", data);
                    }


                     // Update forecast (take the next 5 days from daily array, excluding today)
                    if (data.daily && data.daily.length > 1) {
                         this.forecastWeather = data.daily.slice(1, 6).map(day => ({
                             date: day.dt,
                             dateString: new Date(day.dt * 1000).toLocaleDateString([], { weekday: 'short', day: 'numeric', month: 'short' }), // Format date
                             minTemp: day.temp.min,
                             maxTemp: day.temp.max,
                             description: day.weather[0]?.description || '',
                             icon: day.weather[0]?.icon || ''
                         }));
                         console.log(`Forecast updated for ${this.forecastWeather.length} days.`);
                    } else {
                        console.warn("Daily forecast data missing or insufficient:", data);
                        if (!this.weatherError) { // Only set error if no other error occurred
                             this.weatherError = "Could not retrieve forecast data for this location.";
                        }
                    }

                } else {
                    this.weatherError = `Location "${city}" not found. Please be more specific or check spelling.`;
                    console.warn("Geocoding failed:", city);
                }

            } catch (e) {
                console.error("Error fetching weather:", e);
                 let errorMsg = `Failed to fetch weather. ${e.message || 'Unknown error.'}`;
                 if (e.response?.status === 401) errorMsg = "Failed to fetch weather: Authentication error. Check your OpenWeatherMap API key.";
                 else if (e.response?.status === 404) errorMsg = `Failed to fetch weather: Location "${city}" not found.`;
                 else if (e.response?.status === 429) errorMsg = "Failed to fetch weather: Rate limit exceeded. Try again later.";
                 else if (e.response) errorMsg = `Failed to fetch weather. Status: ${e.response.status}. Message: ${e.response.data?.message || 'No message provided.'}`;
                 this.weatherError = errorMsg;
                 this.addNotification(this.weatherError, "error");
            } finally {
                this.weatherLoading = false;
                 // If weather was fetched successfully (currentWeather is set and has a name, and no general error) and city input is not empty, save the city to profile
                 if (this.currentWeather && this.currentWeather.name && !this.weatherError && this.farmerLocationCity.trim()) {
                     this.saveFarmerCity();
                 }
            }
        },
        getWeatherIconUrl(iconCode) {
            // Get the URL for the OpenWeatherMap icon
             if (!iconCode) return '';
             return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
        },
        saveFarmerCity() {
            // Save the farmer's chosen city to their profile in local storage
             if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier || !this.farmerLocationCity.trim()) {
                 // Only save if logged in as farmer, has an identifier, and entered a city
                 return;
             }
            const profile = this.allUserProfiles[this.currentUserIdentifier];
            if (profile) {
                this.$set(profile, 'farmerLocationCity', this.farmerLocationCity.trim());
                this.saveDataToLocalStorage();
                 console.log(`Farmer city "${this.farmerLocationCity.trim()}" saved to profile.`);
            } else {
                 console.warn(`Cannot save farmer city: Profile not found for ${this.currentUserIdentifier}`);
            }
        },

        // --- Plant Recommendation (Gemini AI) ---
        handlePlantImageUpload(event) {
             // Handle file input change for plant image
            const file = event.target.files[0];
            if (file) {
                if (!file.type.startsWith('image/')) {
                    this.analysisErrorText = 'Please upload a valid image file.';
                    this.plantImageFile = null;
                    if (this.plantImageUrl) URL.revokeObjectURL(this.plantImageUrl);
                    this.plantImageUrl = null;
                    this.plantImageMimeType = null;
                    this.analysisResultText = '';
                    this.parsedAnalysis = { plantName: null, diseaseName: null, treatmentRecommended: null };
                    this.addNotification(this.analysisErrorText, 'warning');
                    return;
                }

                this.plantImageFile = file;
                if (this.plantImageUrl) URL.revokeObjectURL(this.plantImageUrl); // Revoke previous URL
                this.plantImageUrl = URL.createObjectURL(file); // Create new preview URL
                this.plantImageMimeType = file.type;
                this.analysisErrorText = ''; // Clear previous errors
                this.analysisResultText = ''; // Clear previous results
                this.parsedAnalysis = { plantName: null, diseaseName: null, treatmentRecommended: null }; // Clear previous parsed results
                console.log(`Plant image selected: ${file.name}, size ${file.size} bytes, type ${file.type}`);
            } else {
                this.plantImageFile = null;
                if (this.plantImageUrl) URL.revokeObjectURL(this.plantImageUrl); // Clean up previous URL
                this.plantImageUrl = null;
                this.plantImageMimeType = null;
                this.analysisResultText = '';
                this.parsedAnalysis = { plantName: null, diseaseName: null, treatmentRecommended: null };
                console.log("Plant image selection cancelled.");
            }
        },
        async analyzePlant() {
             // Send the uploaded plant image and prompt to Gemini Vision API
            if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) return; // UI should prevent this and check auth
            if (!this.plantImageFile) {
                this.analysisErrorText = 'Please upload a plant image first.';
                this.addNotification(this.analysisErrorText, 'warning');
                return;
            }
             // Check Gemini API key configuration
             if (this.geminiApiKey === 'YOUR_GEMINI_API_KEY_HERE' || !this.geminiApiKey || this.geminiApiKey.includes('YOUR_')) {
                 this.analysisErrorText = "Gemini API key is not configured. Please replace the placeholder in the code.";
                 console.error("Gemini API Key Error:", this.analysisErrorText);
                 this.addNotification(this.analysisErrorText, "error");
                 return;
             }

            this.analysisInProgress = true;
            this.analysisErrorText = '';
            this.analysisResultText = '';
            this.parsedAnalysis = { plantName: null, diseaseName: null, treatmentRecommended: null }; // Reset results
            this.showLoadingModal = true;
            this.loadingMessage = "Analyzing plant image with Gemini AI...";

            try {
                // Read the image file as a data URL or ArrayBuffer
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // Ensure base64 string format is correct (remove data URL prefix)
                        const base64Data = e.target.result.split(',')[1];
                        if (!base64Data) {
                             throw new Error("Failed to extract base64 image data.");
                        }

                        const image = {
                            inlineData: {
                                data: base64Data,
                                mimeType: this.plantImageMimeType || 'image/jpeg', // Default to jpeg if type unknown
                            },
                        };

                        // Define the prompt
                        const prompt = [
                            { text: "Analyze this plant image for identification and disease detection. Identify the plant type. Identify any diseases or pests visible, or state if healthy. Provide a concise, actionable recommendation for treatment or care based on the detected issue. Format your response clearly, ideally like:\nPlant: [Plant Name]\nDisease: [Disease or 'Healthy'/'Not apparent']\nTreatment: [Recommended Treatment or 'No specific treatment needed']\n" },
                            image,
                        ];

                        console.log("Sending request to Gemini Vision API...");
                        const response = await axios.post(
                            `https://generativelanguage.googleapis.com/v1/models/gemini-pro-vision:generateContent?key=${this.geminiApiKey}`,
                            { contents: [{ parts: prompt }] },
                            { timeout: 30000 } // 30 seconds timeout
                        );

                        console.log("Gemini API Response:", response.data);
                        // Extract text content, handle potential empty responses
                        this.analysisResultText = response.data.candidates?.[0]?.content?.parts?.[0]?.text || 'No analysis result received from AI.';
                        console.log("Raw Analysis Text:", this.analysisResultText);

                        // Attempt to parse the structured response text
                        this.parseAnalysisResult(this.analysisResultText);

                        // Show success notification
                         if (this.parsedAnalysis.plantName || this.parsedAnalysis.diseaseName || this.parsedAnalysis.treatmentRecommended) {
                             this.addNotification('Plant analysis complete!', 'success');
                         } else {
                              this.addNotification('Plant analysis completed, but results are unclear.', 'warning');
                         }


                    } catch (readError) {
                         console.error("FileReader or Axios error during analysis:", readError);
                        let errorMsg = `Analysis failed: ${readError.message || 'Unknown error'}`;
                         if (readError.response) {
                            errorMsg += ` Status: ${readError.response.status}.`;
                            if (readError.response.data) errorMsg += ` Data: ${JSON.stringify(readError.response.data)}`;
                             if (readError.response.status === 400) errorMsg = "Analysis failed: Bad request. Check image quality or format.";
                             else if (readError.response.status === 401) errorMsg = "Analysis failed: Authentication error. Check your Gemini API key.";
                             else if (readError.response.status === 429) errorMsg = "Analysis failed: Rate limit exceeded. Try again later.";
                         }
                         this.analysisErrorText = errorMsg;
                         this.addNotification(errorMsg, 'error');
                    } finally {
                         this.analysisInProgress = false;
                         this.showLoadingModal = false;
                    }
                };
                reader.onerror = (e) => {
                     console.error("FileReader error:", e);
                     this.analysisErrorText = `Error reading image file: ${reader.error?.message || 'Unknown error.'}`;
                     this.analysisInProgress = false;
                     this.showLoadingModal = false;
                     this.addNotification(this.analysisErrorText, 'error');
                };
                 // Start reading the file as a Data URL
                reader.readAsDataURL(this.plantImageFile);

            } catch (e) {
                console.error("Error initiating file reading:", e);
                 this.analysisErrorText = `Error preparing image for analysis: ${e.message || 'Unknown error'}`;
                 this.analysisInProgress = false;
                 this.showLoadingModal = false;
                 this.addNotification(this.analysisErrorText, 'error');
            }
        },
        parseAnalysisResult(text) {
             // Attempt to parse the analysis result string into structured data
            if (!text) {
                this.$set(this.parsedAnalysis, 'plantName', null);
                this.$set(this.parsedAnalysis, 'diseaseName', null);
                this.$set(this.parsedAnalysis, 'treatmentRecommended', null);
                return;
            }

            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let plantName = null;
            let diseaseName = null;
            let treatmentRecommended = null;
            let currentSection = null;
            let treatmentLines = [];

            for (const line of lines) {
                 // Check for specific headers case-insensitively, allowing variations like ":" or just space
                 const lowerLine = line.toLowerCase();
                 let content = '';

                 if (lowerLine.startsWith('plant:') || lowerLine.startsWith('plant ')) {
                    content = line.substring(lowerLine.startsWith('plant:') ? 'plant:'.length : 'plant '.length).trim();
                    plantName = content;
                    currentSection = 'Plant';
                } else if (lowerLine.startsWith('disease:') || lowerLine.startsWith('disease ')) {
                     content = line.substring(lowerLine.startsWith('disease:') ? 'disease:'.length : 'disease '.length).trim();
                    diseaseName = content;
                     // Clean up common variations
                    if (diseaseName) {
                         diseaseName = diseaseName.replace(/['"\.]/g, '').trim(); // Remove quotes/periods
                         if (diseaseName.toLowerCase() === 'none' || diseaseName.toLowerCase() === 'no disease' || diseaseName.toLowerCase() === 'no issues apparent' || diseaseName.toLowerCase() === 'not detected' || diseaseName.toLowerCase() === 'not visible') diseaseName = 'Healthy / Not Apparent'; // Combine common "healthy" states
                    } else {
                        diseaseName = 'Unknown'; // Default if Disease line is empty
                    }
                    currentSection = 'Disease';
                } else if (lowerLine.startsWith('treatment:') || lowerLine.startsWith('treatment ')) {
                    content = line.substring(lowerLine.startsWith('treatment:') ? 'treatment:'.length : 'treatment '.length).trim();
                    treatmentRecommended = content; // Start the treatment text
                    treatmentLines = []; // Reset lines for new treatment
                    currentSection = 'Treatment';
                } else if (currentSection === 'Treatment') {
                    // Append subsequent lines if we are still within the Treatment section
                    treatmentLines.push(line);
                } else if (currentSection === 'Description' && treatmentRecommended === null){
                    // If there's a description section before treatment, ignore it for parsing simplicity
                    // Add a check if treatment hasn't been found yet
                }
            }

            // Combine treatment lines if any were found
             // If treatmentRecommended was initially null (no "Treatment:" header found), but we collected lines *after* "Disease:", assume those lines are the treatment.
             if (treatmentRecommended === null && treatmentLines.length > 0) {
                treatmentRecommended = treatmentLines.join('\n').trim();
             } else if (treatmentRecommended !== null && treatmentLines.length > 0) {
                 // Append collected lines to the text that followed the "Treatment:" header
                 treatmentRecommended = (treatmentRecommended ? treatmentRecommended + '\n' : '') + treatmentLines.join('\n').trim();
             }


            // Update reactive properties using $set
            this.$set(this.parsedAnalysis, 'plantName', plantName || 'Unknown'); // Default if not found
            this.$set(this.parsedAnalysis, 'diseaseName', diseaseName || 'Unknown');
            this.$set(this.parsedAnalysis, 'treatmentRecommended', treatmentRecommended || 'No specific treatment recommended.');
            console.log("Parsed Analysis:", this.parsedAnalysis);
        },


         // Helper functions that were already present
         ipfsUrl(cid) {
             // Construct URL to view IPFS CID via gateway
             if (!cid || !this.pinataGateway || this.pinataGateway.includes('YOUR_')) {
                 // Fallback to a generic public gateway if yours isn't set or is placeholder
                  console.warn("Pinata Gateway not configured, using default gateway. Playback may not work.");
                  return `https://ipfs.io/ipfs/${cid}`;
             }
             // Simple format: https://[gateway]/ipfs/[cid]
             return `https://${this.pinataGateway}/ipfs/${cid}`;
         },
         solanaExplorerUrl(txHash) {
             // Construct URL to view simulated transaction on Solana Explorer (using Devnet as example)
              if (!txHash) return '#'; // Placeholder link
              // Note: Since this is a simulated tx hash, the actual page on the explorer won't exist unless you replace the simulation with real Solana TXs.
             return `https://explorer.solana.com/tx/${txHash}?cluster=devnet`;
         },
          async simulateTransaction(message = "Processing transaction...") {
              // Simulates a blockchain transaction delay and returns a fake hash
              console.log(`Simulating transaction: ${message}`);
              this.showLoadingModal = true;
              this.loadingMessage = message;

              await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate network time

              const dummyTxHash = 'SimTx_' + Date.now().toString(16) + Math.random().toString(16).substring(2, 10);

              this.showLoadingModal = false;
              console.log(`Simulated transaction complete. Hash: ${dummyTxHash}`);
              return dummyTxHash; // Return a dummy hash
          },
         isListed(cid) {
             // Check if a video CID is already used in one of the current farmer's listings
              if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier || !this.allListings) return false; // Check all listings
              return this.allListings.some(l => l.cid === cid && l.farmerWallet === this.currentUserIdentifier && l.status !== 'sold'); // Only count active listings
          },
          isUsedInFunding(cid) {
              // Check if a video CID is already used in one of the current farmer's funding requests
               if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier || !this.allFundingRequests) return false; // Check all funding requests
               return this.allFundingRequests.some(r => r.cid === cid && r.farmerWallet === this.currentUserIdentifier && r.status !== 'cancelled'); // Only count active/pending requests
          },
         goToListing(cid) {
             // Helper to navigate to the farmer sell page and pre-select the video
              console.log(`Navigating to farmerSell to list CID: ${cid}`);
              this.navigateToPageWithParam('farmerSell', 'cid', cid);
         },
         scrollToAndHighlightAgriStreamVideo() {
             // Finds the video card element by ref and scrolls it into view, adding a temporary highlight
             if (!this.targetAgriStreamVideoCid) return;

             const ref = this.$refs['videoCard-' + this.targetAgriStreamVideoCid];
             if (ref && ref[0]) {
                 const element = ref[0];
                 element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                 this.highlightedAgriStreamVideoCid = this.targetAgriStreamVideoCid;

                 // Remove the highlight after a few seconds
                 setTimeout(() => {
                     this.highlightedAgriStreamVideoCid = null;
                     this.targetAgriStreamVideoCid = null; // Clear the target after highlighting
                 }, 3000); // Highlight duration
             } else {
                 console.warn(`Element with ref videoCard-${this.targetAgriStreamVideoCid} not found for scrolling/highlighting.`);
                  this.targetAgriStreamVideoCid = null; // Clear target if element isn't found
             }
         },

         // --- PestiVid (Video Recording) ---
         async startVideo() {
              // Start recording video from user's camera
             console.log("Attempting to start video recording...");
             this.uploadCid = ''; // Clear previous upload result
             this.uploadError = ''; // Clear previous error
             this.recordBlobUrl = ''; // Clear previous recording preview
             this.showLive = false; // Hide live feed until started
             this.recording = true; // Set recording state
              this.lastUploadedVideoPurpose = ''; // Clear previous purpose

             try {
                  // Ensure previous stream/recorder are stopped
                  if (this.recordStream) {
                      this.recordStream.getTracks().forEach(track => track.stop());
                  }
                  if (this.recordMediaRecorder) {
                      this.recordMediaRecorder = null;
                  }

                  // Get user media (video only for this demo)
                 const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                 this.recordStream = stream;
                 this.$refs.liveVideo.srcObject = stream;
                 this.showLive = true; // Show live feed

                  // Create MediaRecorder instance
                 const options = { mimeType: 'video/webm; codecs=vp9' }; // Prefer webm/vp9 for wider browser support
                 if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                     console.warn(`${options.mimeType} is not supported, trying video/webm`);
                     options.mimeType = 'video/webm';
                     if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                          console.warn('video/webm is not supported either, trying video/mp4...');
                          options.mimeType = 'video/mp4'; // Fallback to mp4 (less likely to be supported by default)
                          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                               console.error('Neither video/webm nor video/mp4 is supported!');
                               throw new Error('MediaRecorder is not supported with required codecs in this browser.');
                          }
                     }
                 }

                 this.recordMediaRecorder = new MediaRecorder(stream, options);
                 const chunks = [];

                 this.recordMediaRecorder.ondataavailable = (event) => {
                     if (event.data.size > 0) {
                         chunks.push(event.data);
                     }
                 };

                 this.recordMediaRecorder.onstop = () => {
                     this.recordBlob = new Blob(chunks, { 'type' : chunks[0].type });
                     this.recordBlobUrl = URL.createObjectURL(this.recordBlob); // Create preview URL
                     this.showLive = false; // Hide live feed
                     // Do NOT stop the stream here. Stop it after the blob is successfully created.
                     // This prevents the camera light turning off too soon on some browsers.
                     if (this.recordStream) {
                        this.recordStream.getTracks().forEach(track => track.stop()); // Stop the stream
                     }
                      console.log("Recording stopped. Blob created:", this.recordBlob);
                 };

                 this.recordMediaRecorder.start();
                  console.log("Recording started.");

             } catch (err) {
                 console.error("Error starting video recording:", err);
                 this.uploadError = `Could not start video recording: ${err.message}. Make sure you allow camera access.`;
                 this.recording = false;
                 this.showLive = false;
                  if (this.recordStream) {
                     this.recordStream.getTracks().forEach(track => track.stop());
                  }
                  this.addNotification(this.uploadError, 'error');
             }
         },
         stopVideo() {
             // Stop the active video recording
             console.log("Attempting to stop video recording...");
             if (this.recordMediaRecorder && this.recordMediaRecorder.state !== 'inactive') {
                 this.recordMediaRecorder.stop();
                 this.recording = false;
                  console.log("MediaRecorder stop called.");
             } else if (this.recordStream) {
                  // If recorder wasn't active but stream is, stop stream directly
                  this.recordStream.getTracks().forEach(track => track.stop());
                  this.showLive = false;
                  this.recording = false;
                  console.log("Media stream stopped directly.");
             } else {
                  console.warn("No active recording or stream to stop.");
                  this.recording = false; // Ensure state is false
                  this.showLive = false;
             }
         },
         async uploadVideo() {
             // Upload the recorded video blob to IPFS via Pinata
             if (!this.recordBlob) {
                 this.uploadError = "No video recorded to upload.";
                 this.addNotification(this.uploadError, 'warning');
                 return;
             }
              if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) { // Check auth
                  this.uploadError = "You must be logged in as a Farmer to upload videos.";
                  this.addNotification(this.uploadError, 'error');
                  return;
              }
              // Check API key configuration
              if (this.pinataJwt === 'YOUR_PINATA_JWT' || !this.pinataJwt || this.pinataJwt.includes('YOUR_')) {
                  this.uploadError = "Pinata JWT is not configured. Please replace the placeholder in the code.";
                   this.addNotification(this.uploadError, "error");
                  console.error("Pinata API Key Error:", this.uploadError);
                  return;
              }
              if (this.pinataGateway === 'YOUR_PINATA_GATEWAY_HOSTNAME' || !this.pinataGateway || this.pinataGateway.includes('YOUR_')) {
                  this.uploadError = "Pinata Gateway Hostname is not configured. Please replace the placeholder in the code.";
                  this.addNotification(this.uploadError, "error");
                  console.error("Pinata Gateway Error:", this.uploadError);
                  return;
              }


             console.log("Attempting to upload video to IPFS via Pinata...");
             this.uploading = true;
             this.uploadCid = '';
             this.uploadError = '';
             this.showLoadingModal = true;
             this.loadingMessage = "Uploading video to IPFS...";


             try {
                  // Create a FormData object to send the file
                 const formData = new FormData();
                 // Append the video blob with a filename (optional but good practice)
                 formData.append('file', this.recordBlob, `pestivid_crop_${Date.now()}.${this.recordBlob.type.split('/')[1] || 'webm'}`); // Use correct extension

                  // Add Pinata options metadata (optional)
                  const pinataMetadata = JSON.stringify({
                      name: `PestiVid_Crop_${this.recordForm.crop}_${Date.now()}`,
                      keyvalues: {
                         pestiVidUser: this.currentUserIdentifier,
                         crop: this.recordForm.crop,
                         location: this.recordForm.location,
                         pesticide: this.recordForm.pesticide,
                         pesticideCompany: this.recordForm.pesticideCompany,
                         purpose: this.recordForm.purpose,
                         uploadDate: new Date().toISOString()
                      }
                  });
                 formData.append('pinataMetadata', pinataMetadata);

                  // Add Pinata options (optional)
                  const pinataOptions = JSON.stringify({
                      cidVersion: 0 // Or 1
                  });
                 formData.append('pinataOptions', pinataOptions);


                  // Send the POST request to Pinata's upload endpoint
                 const response = await axios.post("https://api.pinata.cloud/pinning/pinFileToIPFS", formData, {
                     maxBodyLength: 'Infinity', // This is needed to prevent axios from breaking on large files
                     headers: {
                         'Content-Type': `multipart/form-data; boundary=${formData._boundary}`,
                         'Authorization': `Bearer ${this.pinataJwt}` // Use JWT for authentication
                     }
                 });

                 console.log("Pinata Upload Response:", response.data);

                 if (response.data && response.data.IpfsHash) {
                     this.uploadCid = response.data.IpfsHash;
                     this.lastUploadedVideoPurpose = this.recordForm.purpose;
                     console.log("Video uploaded successfully! CID:", this.uploadCid);

                     // Simulate blockchain transaction for upload
                     const txHash = await this.simulateTransaction(`Recording IPFS CID ${this.uploadCid.substring(0, 6)}... on blockchain`);
                     // Note: In a real Solana app, this would be where you mint an NFT or record a TX on-chain referencing the CID.
                     // For this demo, we'll just store the CID and a dummy TX hash.

                     // Save video record to the simulated backend
                     const newVideoRecord = {
                         id: 'vid' + Date.now(), // Unique ID
                         farmerWallet: this.currentUserIdentifier,
                         cid: this.uploadCid,
                         crop: this.recordForm.crop,
                         location: this.recordForm.location,
                         pesticide: this.recordForm.pesticide,
                         pesticideCompany: this.recordForm.pesticideCompany,
                         purpose: this.recordForm.purpose, // Store the intended purpose
                         uploadDate: new Date().toLocaleDateString(),
                         blockchainTx: txHash // Store the simulated blockchain TX
                     };
                     this.allFarmerVideos.unshift(newVideoRecord); // Add to the beginning of the global list
                     // farmerVideos is a computed property and will update automatically

                     this.saveDataToLocalStorage(); // Save updated data

                     this.addNotification("Video uploaded to IPFS and recorded on platform ledger (Simulated)!", "success");

                     // Optional: Redirect or pre-fill form based on purpose
                     if (this.lastUploadedVideoPurpose === 'sell') {
                         // Use $nextTick to ensure data is saved before navigation logic is fully processed
                         this.$nextTick(() => {
                            setTimeout(() => { this.navigateToPageWithParam('farmerSell', 'cid', this.uploadCid); }, 1000); // Redirect to sell page
                         });
                     } else if (this.lastUploadedVideoPurpose === 'funding') {
                          this.$nextTick(() => {
                            setTimeout(() => { this.navigateToPageWithParam('farmerFunding', 'cid', this.uploadCid); }, 1000); // Redirect to funding page
                          });
                     }

                      // Reset form and video state after successful upload
                     this.recordForm = {crop:'', pesticide:'', location:'', pesticideCompany: '', purpose: 'agristream'};
                     if (this.recordBlobUrl) URL.revokeObjectURL(this.recordBlobUrl); // Clean up blob URL
                     this.recordBlob = null;
                     this.recordBlobUrl = '';

                 } else {
                     this.uploadError = "Upload failed: No IPFS hash received.";
                     console.error("Pinata upload response missing hash:", response.data);
                     this.addNotification(this.uploadError, "error");
                 }

             } catch (err) {
                 console.error("Error uploading to Pinata:", err);
                 let errorMsg = `Upload failed: ${err.message || 'Unknown error.'}`;
                 if (err.response) {
                     errorMsg += ` Status: ${err.response.status}.`;
                     if (err.response.data) errorMsg += ` Data: ${JSON.stringify(err.response.data)}`; // Add response data if available
                     if (err.response.status === 401) errorMsg = "Upload failed: Authentication error. Check your Pinata JWT.";
                     if (err.response.status === 429) errorMsg = "Upload failed: Pinata rate limit exceeded. Try again later.";
                 }
                 this.uploadError = errorMsg;
                 this.addNotification(this.uploadError, "error");

             } finally {
                 this.uploading = false;
                 this.showLoadingModal = false;
             }
         },
         // --- Farmer Sell (Listings) ---
        async createListing() {
             if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) { // Check auth
                 this.addNotification("You must be logged in as a Farmer to create listings.", "error");
                 this.switchPage('loginChoice');
                 return;
             }
             if (!this.listingForm.cid) {
                  this.addNotification("Please select a video to list.", "warning");
                  return;
             }
             if (this.listingForm.minPrice === null || this.listingForm.minPrice <= 0 || this.listingForm.maxPrice === null || this.listingForm.maxPrice <= 0 || this.listingForm.minPrice > this.listingForm.maxPrice) {
                  this.addNotification("Please enter valid min/max prices.", "warning");
                  return;
             }

             const selectedVideo = this.farmerVideos.find(v => v.cid === this.listingForm.cid);
              if (!selectedVideo) {
                   this.addNotification("Selected video not found in your uploads.", "error");
                   return;
              }

             console.log(`Creating listing for video CID ${this.listingForm.cid} with price range ${this.listingForm.minPrice}-${this.listingForm.maxPrice}`);

             this.showLoadingModal = true;
             this.loadingMessage = "Creating marketplace listing (Simulated Ledger)...";


             // Simulate blockchain transaction for listing creation
              const txHash = await this.simulateTransaction(`Recording listing for CID ${this.listingForm.cid.substring(0, 6)}...`);
              // Loading modal hidden by simulateTransaction

             if (!txHash) {
                 this.addNotification("Listing creation failed (simulated ledger error).", "error");
                 return; // Stop if simulation failed
             }


             const newListing = {
                 id: 'list' + Date.now(), // Unique ID
                 farmerWallet: this.currentUserIdentifier,
                 cid: this.listingForm.cid,
                 crop: selectedVideo.crop, // Use video details for listing info
                 location: selectedVideo.location,
                 pesticide: selectedVideo.pesticide,
                 pesticideCompany: selectedVideo.pesticideCompany,
                 minPrice: parseFloat(this.listingForm.minPrice.toFixed(2)),
                 maxPrice: parseFloat(this.listingForm.maxPrice.toFixed(2)),
                 status: 'active', // Initial status
                 createdAt: new Date().toISOString(), // Timestamp for 'new' badge
                 txHash: txHash, // Simulated transaction hash
                 notificationSent: false, // Track if buyers were notified for this listing
             };

             this.allListings.unshift(newListing); // Add to global list
             // farmerListings computed property will update automatically

             this.saveDataToLocalStorage(); // Save updated data

             this.createdListingId = newListing.txHash; // Show the simulated tx hash
             this.listingNotificationSent = false; // Reset notification state

             this.addNotification(`Listing created successfully! Tx: ${txHash.substring(0, 10)}...`, "success");
             console.log("Listing created:", newListing);

             // Optionally notify buyers if the checkbox was checked
             if (this.listingForm.notifyBuyers) {
                  this.notifyBuyersAboutListing(newListing); // Call the notification method
             }

             // Reset form after creation
             this.listingForm = {cid:'', minPrice: null, maxPrice: null, notifyBuyers: true};

              // Clear highlighting param if it was set to this CID
              if (this.targetAgriStreamVideoCid === newListing.cid) {
                  this.targetAgriStreamVideoCid = null;
              }

         },
         notifyBuyersAboutListing(listing, manuallyTriggered = false) {
              if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) return; // Auth check
             if (listing.notificationSent && !manuallyTriggered) {
                  console.log(`Notification already sent for listing ${listing.id}.`);
                  return;
              }
             console.log(`Notifying buyers about listing ${listing.id}...`);

             // Simulate sending notifications to all users with the 'buyer' role
             const buyerProfiles = Object.values(this.allUserProfiles).filter(p => p.role === 'buyer');
             const notifiedCount = buyerProfiles.length;

             buyerProfiles.forEach(buyerProfile => {
                 if (buyerProfile.walletAddress !== this.currentUserIdentifier) { // Don't notify the seller themselves
                     this.addNotification(`New crop listing available: "${listing.crop}" by ${this.userName || this.getDisplayIdentifier(this.currentUserIdentifier, 10)}. Price: ${listing.minPrice.toFixed(2)}-${listing.maxPrice.toFixed(2)} SOL.`, 'info', buyerProfile.walletAddress);
                 }
             });

              // Update the listing to mark notification as sent
             const listingInAllIdx = this.allListings.findIndex(l => l.id === listing.id);
              if (listingInAllIdx !== -1) {
                   this.$set(this.allListings[listingInAllIdx], 'notificationSent', true);
                   if (manuallyTriggered) this.listingNotificationSent = true; // Update local state if manual trigger
              }
              this.saveDataToLocalStorage(); // Save updated listing

              if (notifiedCount > 0) {
                console.log(`Simulated notification sent to ${notifiedCount} buyers.`);
                if (manuallyTriggered) {
                    this.addNotification(`Notifications sent to potential buyers for listing "${listing.crop}".`, 'success');
                }
              } else {
                   console.log("No users with the 'buyer' role found to notify.");
                    if (manuallyTriggered) {
                        this.addNotification("No users with the 'buyer' role found to notify.", 'warning');
                   }
              }
         },
         resetBuyerFilters() {
             this.buyerFilters = { crop: '', location: '', pesticideCompany: '' };
             console.log("Buyer filters reset.");
         },

          // --- Investor Funding Requests ---
         async createFundingRequest_V1() {
            if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) { // Check auth
                 this.addNotification("You must be logged in as a Farmer to create funding requests.", "error");
                 this.switchPage('loginChoice');
                 return;
            }
             // Basic form validation
             if (!this.fundingForm.cid || this.fundingForm.acres === null || this.fundingForm.amount === null || this.fundingForm.timeline === null || this.fundingForm.roi === null || this.fundingForm.investorShare === null || !this.fundingForm.title.trim() || !this.fundingForm.crop.trim() || !this.fundingForm.method || !this.fundingForm.description.trim()) {
                 this.addNotification("Please fill in all required fields.", "warning");
                 return;
             }
              if (this.fundingForm.acres <= 0 || this.fundingForm.amount <= 0 || this.fundingForm.timeline <= 0 || this.fundingForm.roi <= 0 || this.fundingForm.roi > 100 || this.fundingForm.investorShare <= 0 || this.fundingForm.investorShare > 80) {
                   this.addNotification("Please enter valid positive values for acres, amount, timeline, ROI (1-100%), and Investor Share (1-80%).", "warning");
                   return;
              }


              const selectedVideo = this.farmerVideos.find(v => v.cid === this.fundingForm.cid);
              if (!selectedVideo) {
                   this.addNotification("Selected video not found in your uploads.", "error");
                   return;
              }


             console.log(`Creating funding request "${this.fundingForm.title}" for CID ${this.fundingForm.cid}`);

             this.showLoadingModal = true;
             this.loadingMessage = "Creating funding request (Simulated Ledger)...";


             // Simulate blockchain transaction for request creation
              const txHash = await this.simulateTransaction(`Recording funding request for CID ${this.fundingForm.cid.substring(0, 6)}...`);
              // Loading modal hidden by simulateTransaction

             if (!txHash) {
                 this.addNotification("Funding request creation failed (simulated ledger error).", "error");
                 return; // Stop if simulation failed
             }


             const newFundingRequest = {
                 id: 'fund' + Date.now(), // Unique ID
                 farmerWallet: this.currentUserIdentifier,
                 cid: this.fundingForm.cid,
                 title: this.fundingForm.title.trim(),
                 crop: this.fundingForm.crop.trim(),
                 acres: parseFloat(this.fundingForm.acres.toFixed(1)),
                 amount: parseFloat(this.fundingForm.amount.toFixed(2)),
                 method: this.fundingForm.method,
                 description: this.fundingForm.description.trim(),
                 timeline: parseInt(this.fundingForm.timeline),
                 roi: parseFloat(this.fundingForm.roi.toFixed(1)),
                 investorShare: parseFloat(this.fundingForm.investorShare.toFixed(1)),
                 fundedAmount: 0, // Track how much is funded
                 investors: [], // Array to store investor details
                 status: 'pending', // Initial status
                 createdAt: new Date().toISOString(), // Timestamp for creation
                 simStartDate: new Date().toISOString(), // Simulated start date for progress tracking
                 // Simulate progress (start at 0)
                 progress: 0, // 0% initially

                 txHash: txHash, // Simulated transaction hash

             };

             this.allFundingRequests.unshift(newFundingRequest); // Add to global list
             // farmerFundingRequests computed property will update automatically

             this.saveDataToLocalStorage(); // Save updated data

             this.createdFundingRequest = true; // Flag to show success message

             this.addNotification(`Funding request "${newFundingRequest.title}" created successfully! Tx: ${txHash.substring(0, 10)}...`, "success");
             console.log("Funding request created:", newFundingRequest);

             // Optional: Notify investors about the new project
              // If notifyInvestors is added to the form/request object later, use that.
              // For now, let's just notify all investors about new requests.
             this.notifyInvestorsAboutFundingRequest(newFundingRequest);


             // Reset form after creation
             this.fundingForm = { title: '', crop: '', acres: null, amount: null, method: '', cid: '', description: '', timeline: null, roi: null, investorShare: null, notifyInvestors: true };

              // Clear highlighting param if it was set to this CID
              if (this.targetAgriStreamVideoCid === newFundingRequest.cid) {
                  this.targetAgriStreamVideoCid = null;
              }
         },
          async cancelFundingRequest_V1(requestId) {
               if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) { // Check auth
                 this.addNotification("You must be logged in as a Farmer to cancel requests.", "error");
                 this.switchPage('loginChoice');
                 return;
               }

              const requestIndex = this.allFundingRequests.findIndex(r => r.id === requestId && r.farmerWallet === this.currentUserIdentifier);

              if (requestIndex === -1) {
                  this.addNotification("Funding request not found or you don't have permission to cancel.", "error");
                  return;
              }

              const requestToCancel = this.allFundingRequests[requestIndex];

               if (requestToCancel.status === 'funded' || requestToCancel.status === 'harvested' || requestToCancel.status === 'cancelled') {
                   this.addNotification(`Request is already ${requestToCancel.status}. Cannot cancel.`, "warning");
                   return;
               }


              console.log(`Attempting to cancel funding request ${requestId}...`);

              this.showLoadingModal = true;
              this.loadingMessage = "Cancelling funding request (Simulated Ledger)...";

               // Simulate refunding investors if partially funded
               let refundTx = null;
               if (requestToCancel.fundedAmount > 0 && requestToCancel.investors && requestToCancel.investors.length > 0) {
                   // Simulate refund transactions for each investor
                    await this.simulateTransaction(`Processing refunds for cancelled request ${requestId.substring(0, 6)}...`);
                    // Create refund transactions for each investor
                     requestToCancel.investors.forEach(inv => {
                         const refundAmount = inv.amount || 0;
                          if (refundAmount <= 0) return;
                          const refundTxHash = 'sim_refund_tx_' + Date.now().toString(16) + '_' + inv.investorId.substring(0, 6) + Math.random().toString(16).substring(2,6);
                          const tx = {
                              id: 'txr' + Date.now() + '_' + inv.investorId.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                              investorWallet: inv.investorId,
                              txHash: refundTxHash,
                              type: 'refund', // Transaction type
                              amount: refundAmount, // The refunded amount
                              date: new Date().toLocaleDateString(),
                              projectId: requestToCancel.id,
                              projectTitle: requestToCancel.title,
                              notes: `Refund for cancelled funding request "${requestToCancel.title}"`
                          };
                          this.allInvestorTransactions.unshift(tx); // Add to global transactions
                           // Notify the investor who received the refund
                           if (inv.investorId === this.currentUserIdentifier) {
                                this.addNotification(`Refund received for cancelled project "${requestToCancel.title}": ${refundAmount.toFixed(2)} SOL.`, 'info');
                           } else {
                                // Add notification for non-current user investors if they load their profile later
                                this.addNotification(`Refund processed for cancelled project "${requestToCancel.title}".`, 'info', inv.investorId);
                           }
                     });
                      // Sort global transactions after adding refunds
                     this.allInvestorTransactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

               }


              // Simulate transaction for cancellation itself (if no refunds were needed, still a state change)
               if (!refundTx) { // Only simulate cancellation tx if no refund tx was already simulated
                   refundTx = await this.simulateTransaction(`Recording cancellation for request ${requestId.substring(0, 6)}...`);
               }
                // Loading modal hidden by simulateTransaction

               if (!refundTx) {
                    // Should not happen if simulateTransaction worked once, but as a fallback...
                   this.addNotification("Request cancellation failed (simulated ledger error).", "error");
                   return;
               }


              // Update the request status
              this.$set(this.allFundingRequests[requestIndex], 'status', 'cancelled');
              this.$set(this.allFundingRequests[requestIndex], 'fundedAmount', 0); // Reset funded amount
               this.$set(this.allFundingRequests[requestIndex], 'investors', []); // Clear investor list
               this.$set(this.allFundingRequests[requestIndex], 'progress', 0); // Reset progress

              this.saveDataToLocalStorage(); // Save updated data

               // Re-filter farmer requests and investor investments/transactions to update views
              this.filterDataForCurrentUser();
               this.updateInvestmentProgress(); // Re-run progress update to ensure states are correct

              this.addNotification(`Funding request "${requestToCancel.title}" cancelled successfully.`, "info");
               console.log("Funding request cancelled:", requestToCancel);
          },
         notifyInvestorsAboutFundingRequest(request) {
              if (!this.bedrockIsAuthenticated || this.role !== 'farmer' || !this.currentUserIdentifier) return; // Auth check
             // Check if notification was already sent (optional, but good practice)
             // if (request.notificationSent) return;

             console.log(`Notifying investors about funding request ${request.id}...`);

             // Simulate sending notifications to all users with the 'investor' role
             const investorProfiles = Object.values(this.allUserProfiles).filter(p => p.role === 'investor');
              let notifiedCount = 0;
             investorProfiles.forEach(investorProfile => {
                 if (investorProfile.walletAddress !== this.currentUserIdentifier) { // Don't notify the farmer themselves
                      notifiedCount++;
                     this.addNotification(`New funding opportunity: "${request.title}" by ${this.userName || this.getDisplayIdentifier(this.currentUserIdentifier, 10)}. Seeking ${request.amount} SOL, Est. ROI ${request.roi}%.`, 'info', investorProfile.walletAddress);
                 }
             });
              console.log(`Simulated notification sent to ${notifiedCount} investors.`);
               // If you wanted to track this, you'd add a 'notificationSent' field to the funding request object and save.
         },
          resetInvestorFilters() {
             this.investorFilters = { crop: '', method: '', minRoi: null, maxAmount: null };
              console.log("Investor filters reset.");
          },
          async investInProject(project) {
              if (!this.bedrockIsAuthenticated || this.role !== 'investor' || !this.currentUserIdentifier) { // Check auth
                  this.addNotification("You must be logged in as an Investor to invest.", "error");
                  this.switchPage('loginChoice');
                  return;
              }
              if (project.farmerWallet === this.currentUserIdentifier) {
                   this.addNotification("You cannot invest in your own project.", "warning");
                   return;
              }

              const amount = this.investmentAmounts[project.id];
              const maxAllowed = this.maxInvestmentAmount(project);

              if (amount === null || amount <= 0 || amount > maxAllowed + 0.00001) { // Add small tolerance for floating point
                   this.$set(this.investmentErrors, project.id, `Please enter a valid amount between 0.01 and ${maxAllowed.toFixed(2)} SOL.`);
                  this.addNotification("Invalid investment amount.", "warning");
                  return;
              }
              this.$set(this.investmentErrors, project.id, ''); // Clear error

              console.log(`Attempting to invest ${amount} SOL in project ${project.id}...`);

              this.showLoadingModal = true;
              this.loadingMessage = `Investing ${amount} SOL in "${project.title}" (Simulated Blockchain)...`;


              // Simulate blockchain transaction for investment
              const txHash = await this.simulateTransaction(`Investing ${amount} SOL in "${project.title.substring(0, 10)}..."`);
              // Loading modal hidden by simulateTransaction

              if (!txHash) {
                  this.addNotification("Investment failed (simulated ledger error).", "error");
                  return; // Stop if simulation failed
              }

              // Record the investment in the global list
              const newInvestment = {
                  id: 'inv' + Date.now() + '_' + this.currentUserIdentifier.substring(0,4) + project.id.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                  investorWallet: this.currentUserIdentifier,
                  projectId: project.id,
                  projectTitle: project.title,
                  farmerWallet: project.farmerWallet, // Store farmer wallet for easy access
                  amount: parseFloat(amount.toFixed(2)), // Store amount as number with 2 decimal places
                  investmentDate: new Date().toLocaleDateString(),
                  txHash: txHash, // Simulated transaction hash
                  status: project.status, // Inherit initial status from project
                  progress: project.progress, // Inherit initial progress from project
                   cid: project.cid, // Store CID for viewing video evidence
                   crop: project.crop, // Store crop for display
                   method: project.method, // Store method
                   description: project.description, // Store description
                   acres: project.acres, // Store acres
                   timeline: project.timeline, // Store timeline
                   roi: project.roi, // Store project's expected ROI at time of investment
                   investorShare: project.investorShare, // Store project's investor share at time of investment
              };
              this.allInvestorInvestments.unshift(newInvestment); // Add to global investments
              // investorInvestments computed property will update automatically

               // Add a simulated transaction record for the investor
               const investorTx = {
                   id: 'txinv' + Date.now() + '_' + this.currentUserIdentifier.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                   investorWallet: this.currentUserIdentifier,
                   txHash: txHash,
                   type: 'investment', // Transaction type
                   amount: amount, // The invested amount
                   date: new Date().toLocaleDateString(),
                   projectId: project.id,
                   projectTitle: project.title,
                   notes: `Investment in project "${project.title}"`
               };
               this.allInvestorTransactions.unshift(investorTx); // Add to global transactions
               // Sort global transactions by date
               this.allInvestorTransactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());


               // Update the funding request object in the global list
               const requestIndex = this.allFundingRequests.findIndex(r => r.id === project.id);
               if (requestIndex !== -1) {
                   const updatedRequest = this.allFundingRequests[requestIndex];
                   const newFundedAmount = (updatedRequest.fundedAmount || 0) + amount;
                   this.$set(updatedRequest, 'fundedAmount', parseFloat(newFundedAmount.toFixed(2)));

                    // Add the investor's details to the request's investor list (for farmer's view)
                    // Check if investor is already listed to avoid duplicates in the investor list array
                    const existingInvestorEntry = updatedRequest.investors.find(inv => inv.investorId === this.currentUserIdentifier);
                     if (existingInvestorEntry) {
                         // Update existing entry if investor invests more
                          this.$set(existingInvestorEntry, 'amount', (existingInvestorEntry.amount || 0) + amount);
                          console.log(`Investor ${this.getDisplayIdentifier(this.currentUserIdentifier, 10)} increased investment in project ${project.id}.`);
                     } else {
                          // Add new investor entry
                           updatedRequest.investors.push({
                               investorId: this.currentUserIdentifier,
                               amount: parseFloat(amount.toFixed(2)),
                               investmentDate: new Date().toLocaleDateString() // When THIS specific investment was made
                            });
                           console.log(`New investor ${this.getDisplayIdentifier(this.currentUserIdentifier, 10)} invested in project ${project.id}.`);
                     }


                   // Update status if fully funded
                   if (updatedRequest.fundedAmount >= updatedRequest.amount && updatedRequest.status === 'pending' || updatedRequest.status === 'partially_funded') {
                        this.$set(updatedRequest, 'status', 'funded');
                        this.$set(updatedRequest, 'simStartDate', new Date().toISOString()); // Start simulated timeline on funding
                         this.addNotification(`Project "${project.title}" is now fully funded!`, 'success', project.farmerWallet); // Notify the farmer
                        console.log(`Project ${project.id} is now fully funded!`);
                   } else if (updatedRequest.fundedAmount > 0 && updatedRequest.status === 'pending') {
                        this.$set(updatedRequest, 'status', 'partially_funded');
                         this.addNotification(`Project "${project.title}" is now partially funded!`, 'info', project.farmerWallet); // Notify the farmer
                        console.log(`Project ${project.id} is now partially funded!`);
                   }
                   // Use $set on the array element itself to ensure Vue detects the change
                   this.$set(this.allFundingRequests, requestIndex, updatedRequest);
                   console.log(`Updated funding request ${project.id}: Funded Amount ${updatedRequest.fundedAmount}, Status ${updatedRequest.status}`);
               } else {
                   console.warn(`Funding request ${project.id} not found in allFundingRequests after investment.`);
               }

              this.saveDataToLocalStorage(); // Save updated data

               // Re-filter investor data to update the portfolio view immediately
               this.filterDataForCurrentUser(); // Updates investorInvestments and investorTransactions
                // Re-filter investorProjects if needed (computed property already does this)
                // Update progress calculation after funding
               this.updateInvestmentProgress(); // Recalculates progress based on potential new start date


               this.addNotification(`Successfully invested ${amount} SOL in "${project.title}"!`, "success");
               console.log("Investment recorded:", newInvestment);

              // Clear the investment amount input for this project
               this.$set(this.investmentAmounts, project.id, null);

               // If viewing investment details modal, update the selectedInvestmentProject to reflect changes
               if (this.showInvestmentDetailsModal && this.selectedInvestmentProject && this.selectedInvestmentProject.id === project.id) {
                    const updatedProject = this.allFundingRequests.find(r => r.id === project.id);
                    if (updatedProject) {
                        // Use Object.assign to update reactively without breaking the reference
                         Object.assign(this.selectedInvestmentProject, updatedProject);
                         console.log("Updated selectedInvestmentProject in modal.");
                    }
               }
          },
         maxInvestmentAmount(project) {
             // Calculate the maximum amount that can still be invested in a project
              if (!project || project.status === 'funded' || project.status === 'harvested' || project.status === 'cancelled' || project.amount === null) {
                  return 0; // No investment possible
              }
              const remaining = project.amount - (project.fundedAmount || 0);
              // Return 0 if remaining is negative (shouldn't happen with correct logic, but safety)
              return Math.max(0, remaining);
         },
         fundingProgressPercent(project) {
             // Calculate the funding progress percentage
              if (!project || project.amount === null || project.amount <= 0) return 0;
              const funded = project.fundedAmount || 0;
              const percent = (funded / project.amount) * 100;
              return Math.min(100, percent).toFixed(1); // Cap at 100%
         },
         calculateExpectedReturn(investment) {
            // Calculate the estimated return for a specific investment
             if (!investment || investment.amount === null || investment.roi === null || investment.investorShare === null || investment.amount <= 0) {
                 return '0.00';
             }
             // Estimated Total Project Profit = (Project Amount * Project ROI) / 100
             // Estimated Investor Profit = Estimated Total Project Profit * (Investor Share / 100)
             // Estimated Investor Total Return = Investor Amount + Estimated Investor Profit
             // Simplified: Investment Amount * (1 + (ROI * Investor Share / 10000))
             const estimatedTotalReturn = investment.amount * (1 + ((investment.roi || 0) * (investment.investorShare || 0) / 10000));
             return estimatedTotalReturn.toFixed(2);
         },
          viewInvestmentDetails(investment) {
              // Find the full project details for the investment and show modal
              console.log(`Viewing details for investment ID: ${investment.id}`);
               if (!investment) return;

               const project = this.allFundingRequests.find(r => r.id === investment.projectId);
               if (!project) {
                   console.warn(`Project details not found for investment ID ${investment.id}, project ID ${investment.projectId}`);
                    this.addNotification("Project details not available for this investment.", "warning");
                   // Show modal anyway with available investment data? Or just don't show modal?
                   // For now, show with available data
                    this.selectedInvestment = investment;
                    // Create a minimal project object based on investment data
                    this.selectedInvestmentProject = {
                         id: investment.projectId,
                         title: investment.projectTitle || 'Project Details Unavailable',
                         crop: investment.crop || 'N/A',
                         method: investment.method || 'N/A',
                         description: investment.description || 'Project description unavailable.',
                         acres: investment.acres,
                         timeline: investment.timeline,
                         roi: investment.roi,
                         investorShare: investment.investorShare,
                         cid: investment.cid,
                         farmerWallet: investment.farmerWallet,
                         fundedAmount: null, // Cannot reliably get this from investment alone
                         amount: null, // Cannot reliably get this from investment alone
                         status: investment.status, // Use investment status
                         progress: investment.progress, // Use investment progress
                         updates: [] // No updates available if project not found
                     };

               } else {
                    console.log("Found project details:", project);
                   this.selectedInvestment = investment;
                   this.selectedInvestmentProject = project; // Use the full project object
               }

               this.showInvestmentDetailsModal = true;
               console.log("Investment details modal showing.");
          },

          // --- Buyer AgriSell ---
         buyListing(listing) {
              if (!this.bedrockIsAuthenticated || this.role !== 'buyer' || !this.currentUserIdentifier) { // Check auth
                 this.addNotification("You must be logged in as a Buyer to purchase.", "error");
                 this.switchPage('loginChoice');
                 return;
             }
             if (listing.farmerWallet === this.currentUserIdentifier) {
                 this.addNotification("You cannot buy your own listing.", "warning");
                 return;
             }

             console.log(`Initiating purchase for listing ID: ${listing.id}`);
             this.selectedListing = listing;
             this.purchaseAmount = null; // Clear previous amount
             this.purchaseStatus = '';
             this.purchaseError = '';
             this.showBuyModal = true;
              console.log("Buy modal showing.");
         },
         closeBuyModal() {
             this.showBuyModal = false;
             this.selectedListing = null;
              console.log("Buy modal closed.");
         },
          async processPurchase() {
              if (!this.selectedListing || !this.bedrockIsAuthenticated || this.role !== 'buyer' || !this.currentUserIdentifier) return; // Auth check

              const amount = parseFloat(this.purchaseAmount);
              const minPrice = this.selectedListing.minPrice || 0;
              const maxPrice = this.selectedListing.maxPrice || 0;

              if (amount === null || isNaN(amount) || amount < minPrice || amount > maxPrice) {
                   this.purchaseError = `Please enter a valid offer within the range (${minPrice.toFixed(2)}-${maxPrice.toFixed(2)} SOL).`;
                   this.purchaseStatus = '';
                   this.addNotification(this.purchaseError, "warning");
                   return;
              }
               this.purchaseError = '';
               this.purchaseStatus = 'Processing Purchase...';
               console.log(`Processing purchase of listing ${this.selectedListing.id} for ${amount} SOL...`);

               this.showLoadingModal = true;
               this.loadingMessage = `Processing purchase of "${this.selectedListing.crop.substring(0, 10)}..." for ${amount} SOL (Simulated Blockchain)...`;


               // Simulate blockchain transaction for purchase
               const txHash = await this.simulateTransaction(`Purchasing "${this.selectedListing.crop.substring(0, 10)}..." for ${amount} SOL`);
               // Loading modal hidden by simulateTransaction

               if (!txHash) {
                   this.purchaseStatus = 'Purchase failed (simulated ledger error).';
                   this.addNotification(this.purchaseStatus, "error");
                   return; // Stop if simulation failed
               }

               // Record the purchase in the global list (for buyer's history)
               const newPurchase = {
                   id: 'buy' + Date.now() + '_' + this.currentUserIdentifier.substring(0,4) + this.selectedListing.id.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                   buyerWallet: this.currentUserIdentifier,
                   listingId: this.selectedListing.id,
                   farmerWallet: this.selectedListing.farmerWallet, // Store farmer wallet
                   cid: this.selectedListing.cid, // Store CID for viewing video evidence
                   crop: this.selectedListing.crop, // Store crop for display
                   location: this.selectedListing.location, // Store location
                   pesticide: this.selectedListing.pesticide, // Store pesticide
                   pesticideCompany: this.selectedListing.pesticideCompany, // Store company
                   price: amount, // The final agreed price
                   date: new Date().toLocaleDateString(), // Purchase date
                   txHash: txHash, // Simulated transaction hash
               };
               this.allBuyerPurchases.unshift(newPurchase); // Add to global purchases
               // buyerPurchases computed property will update automatically


                // Record the transaction for the buyer (in their transaction history)
                const buyerTx = {
                    id: 'txbuy' + Date.now() + '_' + this.currentUserIdentifier.substring(0,4) + Math.random().toString(16).substring(2,4), // Unique ID
                    investorWallet: this.currentUserIdentifier, // Buyer is also an investor in terms of platform transactions
                    txHash: txHash,
                    type: 'purchase', // Transaction type
                    amount: amount, // The purchased amount
                    date: new Date().toLocaleDateString(),
                    listingId: this.selectedListing.id,
                    crop: this.selectedListing.crop,
                    notes: `Purchase of "${this.selectedListing.crop}" from ${this.getDisplayIdentifier(this.selectedListing.farmerWallet, 10)}`
                };
                 // Add to global transactions - Note: Using allInvestorTransactions array for simplicity, might need separate array in real app
                this.allInvestorTransactions.unshift(buyerTx); // Add to global transactions
                this.allInvestorTransactions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()); // Sort by date


               // Update the listing status to sold in the global list
               const listingIndex = this.allListings.findIndex(l => l.id === this.selectedListing.id);
               if (listingIndex !== -1) {
                   this.$set(this.allListings[listingIndex], 'status', 'sold'); // Mark as sold
                   // You might also want to set a soldDate or buyerWallet here
                   this.$set(this.allListings[listingIndex], 'buyerWallet', this.currentUserIdentifier);
                    this.$set(this.allListings[listingIndex], 'soldDate', new Date().toISOString());
                   console.log(`Listing ${this.selectedListing.id} marked as sold.`);
               } else {
                    console.warn(`Listing ${this.selectedListing.id} not found in allListings after purchase.`);
               }

              this.saveDataToLocalStorage(); // Save updated data

               // Re-filter buyer data to update the portfolio view immediately
               this.filterDataForCurrentUser(); // Updates buyerPurchases and investorTransactions (if used for buyer tx)

               this.purchaseStatus = `Purchase complete! Transaction ID: ${txHash.substring(0, 10)}...`;
               this.addNotification(`Successfully purchased "${this.selectedListing.crop}" for ${amount} SOL!`, "success");

              // Simulate notification to the seller (farmer)
               this.addNotification(`Your listing "${this.selectedListing.crop}" has been sold to ${this.userName || this.getDisplayIdentifier(this.currentUserIdentifier, 10)} for ${amount} SOL.`, 'info', this.selectedListing.farmerWallet);


               // Close the modal after a short delay
               setTimeout(() => {
                   this.closeBuyModal();
               }, 2000); // Keep success message visible for a bit

          },
         viewPurchaseDetails(purchase) {
             // Set selected purchase and show modal
              console.log(`Viewing purchase details for purchase ID: ${purchase.id}`);
             this.selectedPurchase = purchase;
             this.showPurchaseVideo = true;
              console.log("Purchase video modal showing.");
         },


         // --- Utilities ---
         // Function to remove an item from an array by ID (generic helper)
         removeItemById(array, id) {
             const index = array.findIndex(item => item.id === id);
             if (index !== -1) {
                 array.splice(index, 1);
                 return true; // Item removed
             }
             return false; // Item not found
         },
          // Function to find an item in an array by ID (generic helper)
         findItemById(array, id) {
             return array.find(item => item.id === id);
         },

         // Helper for showing loading modal
          showLoading(message = "Loading...") {
             this.loadingMessage = message;
             this.showLoadingModal = true;
          },
          hideLoading() {
             this.showLoadingModal = false;
             this.loadingMessage = '';
          },


    },
    // Define the ref property for the BedrockStateBridge
    // This allows Vue to get a reference to the React component instance
    // and call methods exposed via useImperativeHandle
    refs: {
        bedrockBridge: null // This will hold the ref to the BedrockStateBridge component instance
    }
});
</script>

</body>
</html>