
import { Connection, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';
import { Program, AnchorProvider, web3 } from '@project-serum/anchor';
import idl from './idl.json'; // The IDL (Interface Definition Language) file generated by Anchor

// --- Constants ---
const PROGRAM_ID = new PublicKey(idl.metadata.address);
const SOLANA_NETWORK = 'https://api.devnet.solana.com'; // Using Devnet for development

let connection = new Connection(SOLANA_NETWORK, 'confirmed');

// --- Helper Functions ---

/**
 * Gets the Anchor provider from the connected wallet.
 * The provider is an abstraction of a connection to the Solana network.
 * @returns {AnchorProvider} The Anchor provider.
 */
function getProvider() {
    const wallet = window.solana;
    if (!wallet) {
        throw new Error("Solana wallet not found!");
    }
    const provider = new AnchorProvider(connection, wallet, { preflightCommitment: 'processed' });
    return provider;
}

/**
 * Gets an instance of the on-chain program.
 * @returns {Program} The program instance.
 */
function getProgram() {
    const provider = getProvider();
    return new Program(idl, PROGRAM_ID, provider);
}

// --- Core API Functions ---

/**
 * Checks if a user profile exists for the connected wallet.
 * @returns {Promise<boolean>} True if the profile exists, false otherwise.
 */
export async function userProfileExists() {
    const provider = getProvider();
    const [userProfilePDA, _] = await PublicKey.findProgramAddress(
        [Buffer.from("user_profile"), provider.wallet.publicKey.toBuffer()],
        PROGRAM_ID
    );
    const accountInfo = await connection.getAccountInfo(userProfilePDA);
    return accountInfo !== null;
}

/**
 * Creates a new user profile on the blockchain.
 * @param {string} role - The user's selected role (farmer, buyer, investor).
 * @param {string} name - The user's full name.
 * @param {string} email - The user's email address.
 * @param {string} phone - The user's phone number.
 * @param {string} memberSince - The date the user joined.
 * @returns {Promise<string>} The transaction signature.
 */
export async function createUserProfile(role, name, email, phone, memberSince) {
    const program = getProgram();
    const provider = getProvider();

    const [userProfilePDA, _] = await PublicKey.findProgramAddress(
        [Buffer.from("user_profile"), provider.wallet.publicKey.toBuffer()],
        PROGRAM_ID
    );

    const tx = await program.methods
        .createUserProfile(role, name, email, phone, memberSince)
        .accounts({
            userProfile: userProfilePDA,
            user: provider.wallet.publicKey,
            systemProgram: SystemProgram.programId,
        })
        .rpc();

    return tx;
}

/**
 * Fetches all video metadata accounts from the blockchain.
 * @returns {Promise<Array>} A list of all video accounts.
 */
export async function fetchAllVideos() {
    const program = getProgram();
    const videoAccounts = await program.account.videoMetadata.all();
    return videoAccounts;
}

/**
 * Creates video metadata on the blockchain after a file is uploaded to IPFS.
 * @param {object} videoData - The video metadata.
 * @returns {Promise<string>} The transaction signature.
 */
export async function createVideoMetadata(videoData) {
    const program = getProgram();
    const provider = getProvider();

    const [userProfilePDA, _] = await PublicKey.findProgramAddress(
        [Buffer.from("user_profile"), provider.wallet.publicKey.toBuffer()],
        PROGRAM_ID
    );

    const userProfile = await program.account.userProfile.fetch(userProfilePDA);

    const [videoPDA, __] = await PublicKey.findProgramAddress(
        [Buffer.from("video"), provider.wallet.publicKey.toBuffer(), Buffer.from([userProfile.videoCount])],
        PROGRAM_ID
    );

    const tx = await program.methods
        .createVideoMetadata(
            videoData.ipfs_cid,
            videoData.video_file_hash,
            videoData.crop,
            videoData.pesticide,
            videoData.location,
            videoData.pesticide_company,
            videoData.purpose
        )
        .accounts({
            video: videoPDA,
            userProfile: userProfilePDA,
            user: provider.wallet.publicKey,
            authority: provider.wallet.publicKey, // This should be checked properly in a real app
            systemProgram: SystemProgram.programId,
        })
        .rpc();

    return tx;
}

/**
 * Fetches all marketplace listings from the blockchain.
 * @returns {Promise<Array>} A list of all listing accounts.
 */
export async function fetchAllListings() {
    const program = getProgram();
    const listingAccounts = await program.account.listing.all();
    return listingAccounts;
}

/**
 * Creates a new marketplace listing on the blockchain.
 * @param {PublicKey} videoPublicKey - The public key of the video metadata account.
 * @param {number} minPrice - The minimum price in lamports.
 * @param {number} maxPrice - The maximum price in lamports.
 * @returns {Promise<string>} The transaction signature.
 */
export async function createListing(videoPublicKey, minPrice, maxPrice) {
    const program = getProgram();
    const provider = getProvider();

    const [listingPDA, _] = await PublicKey.findProgramAddress(
        [Buffer.from("listing"), videoPublicKey.toBuffer()],
        PROGRAM_ID
    );

    const tx = await program.methods
        .createListing(minPrice, maxPrice)
        .accounts({
            listing: listingPDA,
            video: videoPublicKey,
            user: provider.wallet.publicKey,
            authority: provider.wallet.publicKey, // This should be checked properly in a real app
            systemProgram: SystemProgram.programId,
        })
        .rpc();

    return tx;
}
